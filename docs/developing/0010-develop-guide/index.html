<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-developing/0010-develop-guide" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.0.0">
<title data-rh="true">Developer Guide | Virtual Client Platform</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://microsoft.github.io/VirtualClient/docs/developing/0010-develop-guide/"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="keywords" content="performance, benchmarking, automation, framework, microsoft"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Developer Guide | Virtual Client Platform"><meta data-rh="true" name="description" content="Welcome to the Virtual Client development team! The Virtual Client is a .NET 8.0 command line application written in C# that offers both cross-platform and multi-architecture support. As such, the"><meta data-rh="true" property="og:description" content="Welcome to the Virtual Client development team! The Virtual Client is a .NET 8.0 command line application written in C# that offers both cross-platform and multi-architecture support. As such, the"><link data-rh="true" rel="icon" href="/VirtualClient/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://microsoft.github.io/VirtualClient/docs/developing/0010-develop-guide/"><link data-rh="true" rel="alternate" href="https://microsoft.github.io/VirtualClient/docs/developing/0010-develop-guide/" hreflang="en"><link data-rh="true" rel="alternate" href="https://microsoft.github.io/VirtualClient/docs/developing/0010-develop-guide/" hreflang="x-default"><link data-rh="true" rel="preconnect" href="https://0I7D8A07MA-dsn.algolia.net" crossorigin="anonymous"><link rel="alternate" type="application/rss+xml" href="/VirtualClient/blog/rss.xml" title="Virtual Client Platform RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/VirtualClient/blog/atom.xml" title="Virtual Client Platform Atom Feed">



<link rel="search" type="application/opensearchdescription+xml" title="Virtual Client Platform" href="/VirtualClient/opensearch.xml"><link rel="stylesheet" href="/VirtualClient/assets/css/styles.9af2558c.css">
<script src="/VirtualClient/assets/js/runtime~main.24512b64.js" defer="defer"></script>
<script src="/VirtualClient/assets/js/main.cea975e9.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><div class="announcementBar_mb4j" role="banner"><div class="announcementBarPlaceholder_vyr4"></div><div class="content_knG7 announcementBarContent_xLdY">⭐️ If you like VirtualClient, give it a star on <a target="_blank" rel="noopener noreferrer" href="https://github.com/microsoft/VirtualClient">GitHub</a> ⭐️</div><button type="button" aria-label="Close" class="clean-btn close closeButton_CVFx announcementBarClose_gvF7"><svg viewBox="0 0 15 15" width="14" height="14"><g stroke="currentColor" stroke-width="3.1"><path d="M.75.75l13.5 13.5M14.25.75L.75 14.25"></path></g></svg></button></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/VirtualClient/"><div class="navbar__logo"><img src="/VirtualClient/img/vc-logo.png" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/VirtualClient/img/vc-logo.png" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">Virtual Client</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/VirtualClient/docs/overview/">Documentation</a><a class="navbar__item navbar__link" href="/VirtualClient/blog/">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/microsoft/VirtualClient" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG menuWithAnnouncementBar_GW3s"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/VirtualClient/docs/category/overview/">Overview</a><button aria-label="Expand sidebar category &#x27;Overview&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/VirtualClient/docs/category/guides/">Guides</a><button aria-label="Expand sidebar category &#x27;Guides&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/VirtualClient/docs/category/workloads/">Workloads</a><button aria-label="Expand sidebar category &#x27;Workloads&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/VirtualClient/docs/category/monitors/">Monitors</a><button aria-label="Expand sidebar category &#x27;Monitors&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/VirtualClient/docs/category/dependencies/">Dependencies</a><button aria-label="Expand sidebar category &#x27;Dependencies&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" href="/VirtualClient/docs/category/developing/">Developing</a><button aria-label="Collapse sidebar category &#x27;Developing&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/VirtualClient/docs/developing/0001-ci-cd/">Automated Build and CI/CD pipeline</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/VirtualClient/docs/developing/0010-develop-guide/">Developer Guide</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/VirtualClient/docs/developing/0020-develop-extensions/">Developing Extensions</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/VirtualClient/docs/developing/0021-run-custom-scripts/">Run Custom Scripts with Virtual Client</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/VirtualClient/docs/developing/0030-workload-onboarding/">Workload Onboarding Process</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/VirtualClient/docs/developing/0040-vc-packages/">VC Packages</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/VirtualClient/docs/developing/0050-develop-profiling-monitor/">Profiler Integration</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/VirtualClient/docs/developing/0060-workload-recommendations/">Workload Selection Recommendations</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/VirtualClient/docs/developing/0061-build-docker-container/">Building Docker Containers</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/VirtualClient/docs/developing/0070-error-handling/">Error Handling Recommendations</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/VirtualClient/docs/developing/0080-coding-standards/">Coding Standards</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/VirtualClient/docs/developing/0090-testing/">Testing Practices</a></li></ul></li></ul></nav><button type="button" title="Collapse sidebar" aria-label="Collapse sidebar" class="button button--secondary button--outline collapseSidebarButton_PEFL"><svg width="20" height="20" aria-hidden="true" class="collapseSidebarButtonIcon_kv0_"><g fill="#7a7a7a"><path d="M9.992 10.023c0 .2-.062.399-.172.547l-4.996 7.492a.982.982 0 01-.828.454H1c-.55 0-1-.453-1-1 0-.2.059-.403.168-.551l4.629-6.942L.168 3.078A.939.939 0 010 2.528c0-.548.45-.997 1-.997h2.996c.352 0 .649.18.828.45L9.82 9.472c.11.148.172.347.172.55zm0 0"></path><path d="M19.98 10.023c0 .2-.058.399-.168.547l-4.996 7.492a.987.987 0 01-.828.454h-3c-.547 0-.996-.453-.996-1 0-.2.059-.403.168-.551l4.625-6.942-4.625-6.945a.939.939 0 01-.168-.55 1 1 0 01.996-.997h3c.348 0 .649.18.828.45l4.996 7.492c.11.148.168.347.168.55zm0 0"></path></g></svg></button></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/VirtualClient/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/VirtualClient/docs/category/developing/"><span itemprop="name">Developing</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Developer Guide</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><h1 id="developer-guide">Developer Guide</h1>
<p>Welcome to the Virtual Client development team! The Virtual Client is a .NET 8.0 command line application written in C# that offers both cross-platform and multi-architecture support. As such, the
application can run on both Windows and Linux operating systems as well as on hardware with x64 and arm64 architecture CPUs/processors. The following documentation covers details, concepts and
practices to consider when doing development work in the Virtual Client source code. The goal is to enable a developer new to the codebase to quickly understand the high level requirements and expectations before
he/she commits to doing work extending the features of the Virtual Client platform.</p>
<h2 id="preliminaries">Preliminaries</h2>
<p>Before beginning, it is helpful to understand some of the concepts and foundations involved in Virtual Client development. The following links provide
platform overview and design concepts. The remainder of this guide will use terms that are covered in these documents, so it is important to go through
these first.</p>
<p>If you are developing extensions to the Virtual Client platform in another repo, the following documentation can get you started.</p>
<ul>
<li><a href="/VirtualClient/docs/developing/0020-develop-extensions">Developing Virtual Client Extensions</a></li>
</ul>
<p>After going through this developer guide, there are links code examples at the bottom of this document to get you hands-on experience.</p>
<h2 id="terminology">Terminology</h2>
<p>For the sections that follow, the term &#x27;<strong>component</strong>&#x27; is used to describe a Virtual Client action, monitor or dependency. These will be concrete class implementations
referenced in Virtual Client profiles. In the example below, the &#x27;OpenSslExecutor&#x27;, &#x27;DependencyPackageInstallation&#x27; and &#x27;PerfCounterMonitor&#x27; are ALL components. All components
in the Virtual Client derive from the base class &#x27;VirtualClientComponent&#x27;.</p>
<pre><code class="language-json"># In the example below, the OpenSslExecutor, DependencyPackageInstallation and PerfCounterMonitor are all
# generically called &#x27;components&#x27;.
{
    &quot;Description&quot;: &quot;OpenSSL 3.0 CPU Performance Workload&quot;,
    &quot;Parameters&quot;: { },
    &quot;Actions&quot;: [
        {
            &quot;Type&quot;: &quot;OpenSslExecutor&quot;,
            &quot;Parameters&quot;: {
                &quot;Scenario&quot;: &quot;MD5&quot;,
                &quot;CommandArguments&quot;: &quot;speed -elapsed -seconds 100 md5&quot;,
                &quot;PackageName&quot;: &quot;openssl&quot;,
                &quot;Tags&quot;: &quot;CPU,OpenSSL,Cryptography&quot;
            }
        }
    ],
    &quot;Dependencies&quot;: [
        {
            &quot;Type&quot;: &quot;DependencyPackageInstallation&quot;,
            &quot;Parameters&quot;: {
                &quot;Scenario&quot;: &quot;InstallOpenSSLWorkloadPackage&quot;,
                &quot;BlobContainer&quot;: &quot;packages&quot;,
                &quot;BlobName&quot;: &quot;openssl.3.0.0.zip&quot;,
                &quot;PackageName&quot;: &quot;openssl&quot;,
                &quot;Extract&quot;: true
            }
        }
    ]
}
</code></pre>
<pre><code class="language-csharp">// They all derive from the base class VirtualClientComponent

/// &lt;summary&gt;
/// The OpenSSL workload executor component.
/// &lt;/summary&gt;
public class OpenSslExecutor : VirtualClientComponent

/// &lt;summary&gt;
/// The Azure blob package dependency installation component.
/// &lt;/summary&gt;
public class DependencyPackageInstallation : VirtualClientComponent
</code></pre>
<h2 id="practices-and-principles">Practices and Principles</h2>
<p>Before digging into the finer-grained details of development work in the Virtual Client codebase, it is important to understand the high-level practices
and principles the VC Team follows. The practices and principles the team follows are intended to promote rapid software feature development while ensuring
high quality designs and a codebase that can be sustainably maintained over time. These practices are well-vetted learned over many years in the &quot;school of hard
lessons learned&quot;. As such, it is important for developers new to the Virtual Client codebase to follow the practices when possible. That said the most
important thing is to keep things as simple as possible.</p>
<ul>
<li>
<p><strong>Keep it Simple</strong><br>
<!-- -->Whereas it is difficult to keep everything simple all the time when implementing new logic, it is important to try. It helps to focus on the exact
requirements when implementing a solution and to avoid allowing the scope to creep to things that are not actually needed. It is easy to have thoughts
such as &quot;what if we need this in the future&quot;, but this can easily lead to over-engineered solutions with difficult to maintain/extend code. The process
of unit testing (as noted below) is very helpful as a guide for writing just the right amount of code.</p>
</li>
<li>
<p><strong>Enforce isolation with new actions/executors, monitors and dependencies</strong><br>
<!-- -->When developing new actions/executors, monitors or dependencies in Virtual Client, it is important to try to isolate the logic
of that component from other components. Common/shared dependencies used by all Virtual Client components are carefully implemented
in the &#x27;Core&#x27; project; however, other components should be cautious to use shared logic that is NOT a part of the Core. This helps
to prevent a problem with one component from accidentally impacting another. This is an especially important concept given how many
distinct workload executors, monitors and dependencies exist in Virtual Client with the list constantly growing.</p>
</li>
<li>
<p><strong>Functionality that is shared by all components should be part of the &#x27;Core&#x27; project</strong><br>
<!-- -->There are dependencies that are required by most components in the Virtual Client. The implmentations of these hold a high quality bar
because they are so fundamental to the operations of the Virtual Client application as a whole. Most of the necessary dependencies have been
implemented. However if a new dependency is required in Virtual Client that is to be shared across all providers, it should be implemented
in the &#x27;Core&#x27; project. Note that something is not &quot;common&quot; because it might be in the future. A component is common when it is used by many
other components across the codebase. For example, the package manager is used by almost every Virtual Client component. As a general rule,
a new component should not be added to the &#x27;Core&#x27; project until it is definitively used by more than 2 or 3 distinct other components.</p>
<ul>
<li><a href="https://github.com/microsoft/VirtualClient/blob/main/src/VirtualClient/VirtualClient.Core">VirtualClient.Core Project</a></li>
</ul>
</li>
<li>
<p><strong>Unit tests are fundamental to development quality-at-speed.</strong><br>
<!-- -->One of the fundamental goals of the VC Team is to enable high quality development at-speed. To accomplish this as the size
and complexity of the codebase grows, it is very important to have good unit tests in place for each component or supporting
class. The process of writing unit tests acts as a concrete guide in the development process forcing the developer to think
deeply about the code he/she is writing. This is NOT meant to slow the developer down but instead helps to ensure high quality
design with minimal code...it is a particularly good process for this goal. A favorite motto of the team is: &quot;you have to go slow to
go fast&quot;. This means that the developer will invest more time up front in the development process to ensure faster development down
the road. This happens because the code is often well-thought out without being over-engineered and there are programmatic tests
in place protecting the correct functioning of the logic for the future. There are plenty of good examples and patterns in the source
code to follow.</p>
<ul>
<li><a href="/VirtualClient/docs/developing/0090-testing">Testing Guide</a></li>
</ul>
</li>
<li>
<p><strong>Functional tests are required for new profiles.</strong><br>
<!-- -->Functional tests are similar to unit tests except that they focus on the correct integration of all components. When the VC Team creates new
workload or monitoring profiles, functional tests are also created. Whereas unit tests focus on classes meeting all important &quot;specifications&quot;,
functional tests focus on the interactions between components being correct. There are plenty of good examples and patterns in source code
to follow.</p>
</li>
<li>
<p><strong>New profiles (or components within them) must be documented</strong><br>
<!-- -->Each time the VC Team onboards a new workload, monitor or dependency it is documented in the repo within the &#x27;VirtualClient.Documentation&#x27;
folder. Good documentation is an important part of the quality bar that the team holds ensuring that users/customers can always learn more
about the Virtual Client. There are patterns in place within the documentation to guide developers through the process.</p>
</li>
<li>
<p><strong>Components should be implemented to support ALL possible platform/architectures</strong><br>
<!-- -->The Virtual Client is generally designed to run in as many scenarios as possible. To do so, a developer has to consider whether the component
they are onboarding can run on Windows or Linux, x64 (Intel, AMD) or ARM64 architecture. Many times the .NET framework itself provides for the
ability to run cross-OS platform/cross-CPU architecture. However, there are times when the logic must implement support in a slightly different
way. It is always a goal to implement new features and components such that they cover ALL possible scenarios. By doing so, the value of the
Virtual Client to users/partners/customers is increased because it can cover more of the scenarios that are important to them.</p>
</li>
<li>
<p><strong>Components should be written to be idempotent</strong><br>
<!-- -->The term &quot;Idempotent&quot; in this context refers to the ability of a component to be ran any number of times back-to-back without changing the
desired outcome. For example, a component that is responsible for installing a particular dependency should not change the state of that dependency
once installed nor should it fail on a second, third etc... run. A component that is responsible for running a workload or test should be able
to successfully run that workload or test on each and every subsequent run. In practice, this sometimes mean avoiding doing work that has already
been performed (e.g. installing a given dependency) and cleaning up either at the beginning or end of the component execution.</p>
<p>The Virtual Client core platform has a state manager that allows components to preserve state information (in files on the local system) so that they
can be referenced later or on subsequent runs. This is useful for example to save off information that indicates some specific operation was performed
that could fail if attempted a second time in succession.</p>
</li>
</ul>
<h2 id="considerations-when-getting-started">Considerations When Getting Started</h2>
<p>As a developer is starting to think about contributing to the Virtual Client codebase, there are a few things that are helpful to consider as a guide.
The following sections provide some high-level ideas to help form a plan. The sections below are written to account for the onboarding of an entirely
new component (workload, monitor) to the Virtual Client so as to cover the space thoroughly.</p>
<ul>
<li>
<p><strong>Familiarize yourself with the platform concepts</strong><br>
<!-- -->It is important to understand the fundamental concepts for the Virtual Client before beginning. If you did not go through the platform overview
and design documentation at the top, please do so before continuing.</p>
</li>
<li>
<p><strong>Identify your dependencies</strong><br>
<!-- -->One of the very first things to do when getting started with a new component implementation is to identify all of the dependencies that your
component will have. This will inform whether you need to package those as a Virtual Client package or install them in other ways. For example:</p>
<ul>
<li>Workload scripts or binaries.</li>
<li>Dependencies/packages that have to be installed for workload scripts or binaries (e.g. apt, debian, chocolatey).</li>
<li>Configurations/settings for the system/OS (e.g. registry keys, TCP ephemeral ports).</li>
</ul>
</li>
<li>
<p><strong>Identify what type of component you are implementing: action, monitor or dependency</strong><br>
<!-- -->The Virtual Client has 3 key types of components in source: actions, dependencies and monitors. Components that are &quot;Fundamental&quot; belong in the Virtual Client
platform/core repo. Components that are &quot;Domain-Specific&quot; belong in a separate repo. Developers will reference a few key libraries from the Virtual Client platform/core
repo (specifically Contracts and Core libraries published as NuGet packages) for integration.</p>
<ul>
<li>
<p><strong>Actions</strong><br>
<!-- -->Actions are used to implement components that execute workloads/tests or scripts. These represent the benchmarks, validation tests or customer-representative work that is
happening on the system. For example, the &#x27;OpenSslExecutor&#x27; referenced at the top of this document is a component that executes a workload that tests the CPU on the system
called &#x27;OpenSSL SPeed&#x27;. It is an industry-standard cryptography benchmarking workload.</p>
</li>
<li>
<p><strong>Dependencies</strong><br>
<!-- -->Dependencies are used to implement components that setup or install dependencies on the system required by actions and monitors in a profile. For example,
the &#x27;DependencyPackageInstallation&#x27; component referenced at the top of this document is a component that downloads Virtual Client packages from an Azure storage account
to the system at runtime.</p>
</li>
<li>
<p><strong>Monitors</strong><br>
<!-- -->Monitors are used to implement components that run in the background and capture important information from the system under load. For example, the &#x27;PerfCounterMonitor&#x27;
referenced at the top of this document is a component that captures performance counters from the system while workloads/tests are running.</p>
</li>
</ul>
</li>
<li>
<p><strong>Learn how the workload/test, monitor or dependency works</strong><br>
<!-- -->When onboarding a new workload/test or monitor, time MUST be spent learning how it works. This will allow the developer to make and informed decision on how the
application should run as part of defining a Virtual Client profile in which it is integrated. This is very, very important to the goals of the Virtual Client. The user of the
platform should NOT have to know very much about the  or be an expert in it in order to take advantage of the expertise built into Virtual Client on their behalf. In fact, this principle
is fundamental to the idea of the Virtual Client and the primary reason why profiles exist. A profile represents the expertise of the developers that integrated
components into the Virtual Client. This includes the expertise of other teams of subject matter experts consulted during the discovery work. At the end of the day,
a user of the Virtual Client should be able to take advantage of the expertise of many when running a workload and should have trust in the information that is
produced. This depends on you, the developer doing the hard due diligence work to truly understand what the workload does and how to run it effectively.</p>
<p>Team members typically use virtual machines in a subscription for exploratory work to learn how a particular application being onboarded works. Contact the team
using information in the general documentation at the top of this document if you need virtual machine support.</p>
</li>
<li>
<p><strong>Create Virtual Client packages (.vcpkg) for certain dependencies</strong><br>
<!-- -->Many dependencies for the Virtual Client such as a workload or monitor will be packaged in a Virtual Client (.vcpkg) package. Developers do not necessarily
need to create custom VC packages for everything. However, it is common practice to create packages for the Virtual Client containing required dependencies
(e.g. workloads, Java runtime, PowerShell, Python) so that they can be put in a package/blob store for download at runtime. Virtual Client profiles are designed
to download and install required dependencies. This is not required, but it is convenient and helps to make Virtual Client easy to deploy into a wide range of
environments/scenarios.</p>
<p>Another benefit of placing dependencies in custom Virtual Client packages is that it enables Virtual Client to support &quot;disconnected&quot; scenarios. These
are scenarios where the Virtual Client will need to run on a system that does not have a network connection. For example, a set of workloads might require
the Python3 framework to run despite the disconnected scenario. It cannot be downloaded at runtime. In this example, the workloads would be placed in a package
and the Python3 framework libraries in a separate package (for reusability with other workloads in the future). These packages would be deployed with the Virtual
Client in the &#x27;packages&#x27; folder so that there is no need for Virtual Client to download them.</p>
</li>
<li>
<p><strong>Design your workload or monitor profile</strong><br>
<!-- -->Virtual Client profiles represent the interface to the user for your workloads/tests, monitors and dependencies. They represent the expertise that a developer gained
throughout the discovery process for a new component being onboarded to the Virtual Client. It is common for example for a new workload/test to have a single profile
that a user can reference on the command line to run that workload/test in one or more ways that represent a holistic scenario. A profile should define a scenario that
is both whole (in terms of breadth of coverage on a system) as well as trustworthy (in terms of quality of coverage on the system). As noted above, the user should not
need to be an expert in the workload/test or monitor in order to take advantage of the expertise within.</p>
<p>As was covered in the platform design documentation at the top, Virtual client profiles are divided into 2 types of profiles: workload/test profiles and monitoring profiles.
This allows the user to run different workloads/tests on a system with different monitors as they require.</p>
<pre><code>VirtualClient.exe --profile=PERF-CPU-OPENSSL.json --profile=MONITORS-DEFAULT.json --timeout=1440 --system=Demo
</code></pre>
<ul>
<li><a href="https://github.com/microsoft/VirtualClient/blob/main/src/VirtualClient/VirtualClient.Main/profiles">Existing Profiles</a></li>
</ul>
</li>
</ul>
<h2 id="platformcore-projects-and-libraries">Platform/Core Projects and Libraries</h2>
<p>Before beginning the discussion of development/programming aspects of the Virtual Client, the following section covers the important projects that
exist within the Virtual Client platform/core codebase. It is helpful to understand what components are implemented in each of these projects.</p>
<ul>
<li>
<p><strong>VirtualClient.Contracts</strong><br>
<!-- -->This project contains all of the fundamental data contract/model and POCO (plain old C# object) classes that are used by Virtual Client components. This
project additionally contains the logging extensions that are used to create the structured/schematized telemetry foundation that ensures data
emitted by the Virtual Client follows consistent patterns and is easily/readily consumable for data analysis.</p>
</li>
<li>
<p><strong>VirtualClient.Core</strong><br>
<!-- -->This project contains all of the important shared/core dependency interfaces and implementations  used by all Virtual Client components
(e.g. workload executors, monitors and dependency installers/handlers). This is the &quot;common&quot; class library if you will.</p>
</li>
<li>
<p><strong>VirtualClient.Actions</strong><br>
<!-- -->This project contains &quot;Fundamental&quot; workload/test executor implementations. The components within this project can be seen referenced in the
&#x27;Actions&#x27; section of related workload profiles.</p>
<p>This project also contains classes/implementations of various results/raw text parsers that are used in conjuction with workload/test executors
to read important information/data (e.g. metrics) from the output of workloads. The parsing of results is complex enough to
keep the implementation separate from the workload executors and to ensure reusability for different implementations of a related
workload executor.</p>
</li>
<li>
<p><strong>VirtualClient.Api</strong><br>
<!-- -->This project contains the Virtual Client API. This is a self-hosted REST API that allows instances of the Virtual Client running on
different systems to communicate with each other. This is important for workloads that require multi-system/tier topologies to conduct
the workload operations (e.g. client/server interactions).</p>
</li>
<li>
<p><strong>VirtualClient.Dependencies</strong><br>
<!-- -->This project contains &quot;Fundamental&quot; dependency installer/handler classes/implementations. The components within this project can be seen referenced in the
&#x27;Dependencies&#x27; section of related workload or monitoring profiles.</p>
</li>
<li>
<p><strong>VirtualClient.Monitors</strong><br>
<!-- -->This project contains &quot;Fundamental&quot; background monitor implementations. The components within this project can be seen referenced in the
&#x27;Monitors&#x27; section of related monitoring profiles.</p>
<p>This project also contains classes/implementations of various results/raw text parsers that are used in conjuction with monitors
to read important information/data (e.g. metrics) from the output of monitors. The parsing of results is complex enough to
keep the implementation separate from the monitors and to ensure reusability for different implementations of a related
monitor.</p>
</li>
<li>
<p><strong>VirtualClient.Packaging</strong><br>
<!-- -->This project contains workload binaries, scripts etc... required to build certain workload and dependency packages for use with the
Virtual Client.</p>
</li>
<li>
<p><strong>VirtualClient.TestExtensions</strong><br>
<!-- -->This project contains classes/implementations that are used to test Virtual Client codebase components. Mock fixtures for example are used
extensively to reduce duplication and to simplify the setup of different mocks and behaviors in Virtual Client unit and functional tests.
The test assets in the Virtual Client codebase are as equally important as the code for which they are testing. The Virtual Client codebase
utilizes the classes/implementations in this project to enable faster velocity in writing new tests and to ensure consistent patterns
of testing throughout.</p>
</li>
</ul>
<h2 id="virtualclientcomponent">VirtualClientComponent</h2>
<p>The &#x27;VirtualClientComponent&#x27; class is the fundamental base class for all components (e.g. workload/test executors, monitors and dependency installers/handlers) within
the codebase. This class allows certain very common requirements to be consolidated in a single place.</p>
<ul>
<li>
<p><strong>Common/Shared Dependencies</strong><br>
<!-- -->Common dependencies (e.g. package manager, disk manager, file system manager) are passed into the constructors of all components via
an IServiceCollection instance. This is the principle of dependency injection which creates flexibility for both runtime as well as test
time executions of code paths. These coded dependencies are created at the start of the Virtual Client and are available to every component
that runs regardless of when it runs so it is very easy to access the shared platform runtime interfaces.</p>
</li>
<li>
<p><strong>Component Parameters</strong><br>
<!-- -->All parameters that are either defined on the component itself in a workload or monitoring profile or that were passed in on the command line are passed
into the constructor of the component. This allows the component to operate based on parameters defined in the profile or for those that were overridden by
the user on the command line.</p>
</li>
</ul>
<h2 id="commonshared-dependencies">Common/Shared Dependencies</h2>
<p>All workload executors, monitors and dependency installers/handlers share a common set of requirements. These requirements are encapsulated into a set of core interfaces
and implementations in the Virtual Client. The following section describes each of the most important categories of shared dependencies as well as their
implementations. As described above, these commons/shared dependencies are passed into the constructor of all workload executor, monitors and dependency
handlers for use. The interfaces and implementations below exist in the &#x27;VirtualClient.Core&#x27; project as noted above.</p>
<p>Note that the use of interfaces is part of a &quot;program to interfaces&quot; design principle. Whereas the incorporation of interfaces in a codebase increases the
learning curve for developers trying to understand the flow, it is important to keep abstractions to a minimum. As a general rule, the VC Team tries to have a single
interface and implementation for a given dependency. This allows flexibility for different &quot;live&quot; scenarios as well as for deep/robust ability to test the code
for functional correctness.</p>
<ul>
<li>
<p><strong>API Clients</strong><br>
<!-- -->Certain workload scenarios require multiple systems to operate (e.g. networking workloads, client/server). These workloads have a requirement to communicate
with each other to be able to synchronize client-side executions with server-side expectations. The Virtual Client uses an <a href="/VirtualClient/docs/guides/0020-client-server">environment layout</a> provided on
the command line to determine the IP addresses of other instances. API client creation and management is encapsulated in the following interfaces/classes:</p>
<ul>
<li>IApiClientManager</li>
<li>ApiClientManager</li>
</ul>
</li>
<li>
<p><strong>Blob Store Upload/Download Requirements</strong><br>
<!-- -->The Virtual Client supports the ability to upload and download files/content from an Azure storage account blob store (and other cloud blob stores in the future). Blob store interactions
are encapsulated in the following interfaces/classes:</p>
<ul>
<li>IBlobManager</li>
<li>BlobManager</li>
</ul>
</li>
<li>
<p><strong>Disk Management</strong><br>
<!-- -->Certain workloads available in the Virtual Client require the ability to read information from the system about disks attached as well as to initialize/format
the disks. For example, the FIO workload is designed to test the disks on the system for I/O performance. With Azure virtual machines, managed/remoted disks are
typically attached in a raw state uninitialized and unformatted. They must be prepped with a file system before any I/O tests can be ran using them. Disk management
features are encapsulated in the following interfaces/classes:</p>
<ul>
<li>IDiskManager</li>
<li>DiskManager</li>
<li>UnixDiskManager</li>
<li>WindowsDiskManager</li>
</ul>
</li>
<li>
<p><strong>Firewall Management</strong><br>
<!-- -->Some workloads require changes to the firewall on the system in order to operate. This might include opening ports (e.g. TCP, UDP) or enabling certain applications
to execute freely. Firewall management features are encapsulated in the following interfaces/classes:</p>
<ul>
<li>IFirewallManager</li>
<li>FirewallManager</li>
<li>UnixFirewallManager</li>
<li>WindowsFirewallManager</li>
</ul>
</li>
<li>
<p><strong>Package Management</strong><br>
<!-- -->With the sheer number of different workloads available in the Virtual Client, there are a lot of different workload and dependency packages that are required. The application
delegates the responsibility for downloading, extracting and keeping track of all of the various packages using a package manager. The package management foundation
supports the ability to download packages from both NuGet feeds as well as from Azure storage account blob stores. Package management features are encapsulated in the
following interfaces/classes.</p>
<ul>
<li>IPackageManager</li>
<li>PackageManager</li>
</ul>
</li>
<li>
<p><strong>Process Management</strong><br>
<!-- -->The Virtual Client runtime platform execute operating system processes often as part of just about every workload/test executor, monitor or dependency installer/handler. In addition
there are times when processes need to be launched with elevated privileges. The responsibility for creating and managing processes within the runtime is encapsulated in the
following interfaces/classes.</p>
<ul>
<li>ProcessManager</li>
<li>UnixProcessManager</li>
<li>WindowsProcessManager</li>
<li>IProcessProxy</li>
<li>ProcessProxy</li>
</ul>
</li>
<li>
<p><strong>State Management</strong><br>
<!-- -->Certain scenarios require the ability to preserve state information in between operations. For example, there are operations that make configuration settings changes to the
system and then require a reboot. When the Virtual Client is restarted, it needs to know what previous requirements were completed. State management is also very important
for workloads that require multiple systems (client/server) to enable information to be passed back and forth between one instance and another of the Virtual Client. State management
features are encapsulated in the following interfaces/classes:</p>
<ul>
<li>IStateManager</li>
<li>StateManager</li>
</ul>
</li>
<li>
<p><strong>System Management</strong><br>
<!-- -->Because of there are quite a few different dependency interfaces/classes that are required to support the needs of executing a wide range of workloads on the system, all common
dependencies noted above are consolidated together into a single abstraction to simplify the discovery of what is available. Additionally, there are a few requirements that
are extensions to behaviors that use the dependencies above that are a part of the system management abstraction. The following interfaces/abstractions provide for the
common system management features:</p>
<ul>
<li>ISystemInfo</li>
<li>ISystemManagement</li>
<li>SystemManagement</li>
</ul>
</li>
<li>
<p><strong>Telemetry Management</strong><br>
<!-- -->Telemetry is a critical part of the Virtual Client runtime platform operation. Lots and lots of telemetry is emitted and is used for every data-related requirement on the system.
The class implementations used in the Virtual Client ALL follow the .NET team&#x27;s logging patterns using the &#x27;ILogger&#x27; recommendations.</p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/dotnet/core/extensions/logging?tabs=command-line">.NET ILogger interface/pattern</a>.</li>
</ul>
<p>The fundamental classes/interfaces used to emit telemetry in the Virtual Client are as follows:</p>
<ul>
<li>
<p>VirtualClientLoggingExtensions</p>
</li>
<li>
<p>VirtualClientTelemetryExtensions</p>
</li>
<li>
<p>EventContext</p>
</li>
<li>
<p>ConsoleLogger</p>
</li>
<li>
<p>AppInsightsTelemetryLogger</p>
</li>
<li>
<p>EventHubTelemetryLogger</p>
</li>
<li>
<p>SerilogFileLogger</p>
</li>
</ul>
</li>
</ul>
<h2 id="coding-practices">Coding Practices</h2>
<p>The following section describes some of the high-level practices and recommendations to follow when working in the Virtual Client codebase. This is not an
exhaustive list but does illustrate things that are &quot;fundamental&quot; to development in the codebase.</p>
<ul>
<li>
<p><strong>Use the async/await pattern</strong><br>
<!-- -->The C# programming language (as of version 6.0) has great support for asynchronous programming. Asynchronous programming allows for the application to be
far more efficient in the usage of system primitive resources for I/O-bound or CPU-bound operations. The Virtual Client runtime platform itself MUST run as
efficiently as possible. This is especially the case when it is running a resource-sensitive benchmark, workload or test. This is because the resources that the
Virtual Client itself uses in order to operate as a runtime platform on the system affect the resources available t othe workload and can cause &quot;noise&quot; in the
data that is emitted. For example, were the Virtual Client itself to use too many CPU/process resources/cycles when running a workload that is designed to
benchmark the performance of the CPU/processor, the performance results of the benchmark could be skewed to be less accurate.</p>
<p>This pattern is used pervasively throughout the Virtual Client codebase so there are plenty of examples. You can familiarize yourself with asynchronous
programming concepts and techniques in Microsoft public documentation.</p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/dotnet/csharp/async">Asynchronous Programming in C#</a></li>
</ul>
</li>
<li>
<p><strong>Date/Time values should ALWAYS be in universal time (UTC)</strong><br>
<!-- -->When referencing any date/time objects, always represent them in UTC (e.g. DateTime.UtcNow). This is especially important when emitting data. The Virtual Client
runs all over the planet. It is much easier to convert a date in UTC form to any other timezone form. It is much harder to do this the other way around when you do
not know what timezone a date reference was in originally. Suffice to say, just use UTC times everywhere always!</p>
</li>
<li>
<p><strong>Write unit tests at the same time as writing your components</strong><br>
<!-- -->Unit tests programmatically validate the functional correctness of the important behaviors of a given class. Unit testing as a process is extremely important to
the development practices in the Virtual Client. The process of writing unit tests at the same time as writing new components allows the developer a concrete way to check
the quality of the design as well as the code for a new component. In fact, there is no faster way to test new code than a set of unit tests. This is increasingly so over time
as new coded features are added to existing classes. VC Team members follow a hybrid &quot;behavior-driven development&quot; process where unit tests are written incrementally
at the same time as writing the new component code itself. These tests are named as if they are a &quot;specifications&quot; document. Indeed the names of the test methods in the
codebase might surprise folks at times being rather long and descriptive at times. This is very purposeful. Unit tests ARE a specification of a class that is being
developed and should thus read like a list of specs. Correspondingly specifications MUST cover every single discreet/singular behavior that is critical to the correct
functioning of a given class.</p>
<p>Over time as the codebase grows, unit tests act as protection for the quality of the application as a whole. Indeed 80% or better of functional regressions and bugs can be
minimized or eliminated simply by having good unit tests in place. This in turn allows developers to rapidly prototype and implement new features in the Virtual Client
platform (i.e. high quality development at-speed).</p>
</li>
<li>
<p><strong>Use the platform test/mock fixtures to help you write unit tests</strong><br>
<!-- -->The Virtual Client platform/core repo has a set of mock fixtures and extensions in the &#x27;VirtualClient.TestExtensions&#x27; folder that make it easier to do setup and validations in unit
tests. The patterns are pervasive throughout the unit test projects within the platform/core repo. These mock fixtures greatly simplify the process of writing unit tests
at the same time as they help to keep your unit test class code cleaner, simpler and more readable.</p>
</li>
<li>
<p><strong>Use the core dependencies interface &#x27;ISystemManagement&#x27; to integrate with the runtime platform as well as the operating system on which you are running</strong><br>
<!-- -->Every workload/test executor, monitor or dependency needs to access something from the runtime platform or on the operating system. For example, the developer may
need to access the file system, get information about disks on the system, create processes to run a workload or find the location of packages on the system. Core
code dependencies are implemented behind a set of common interfaces as noted above. The &#x27;ISystemManagement&#x27; interface contains/exposes ALL of them in a single place
(e.g. ISystemManagement.DiskManager, ISystemManagement.PackageManager). Because ALL shared dependencies are accessed using these interfaces, the entire codebase can
be thoroughly tested. This is key to keeping the design and functional quality bars high in Virtual Client. The following interfaces are available on the ISystemManagement
interface and can be used:</p>
<ul>
<li>Use the &#x27;IApiClientManager&#x27; instance for API client creation and operations.<!-- -->
<ul>
<li>(i.e. ISystemManagement.ApiClientManager)<br><br></li>
</ul>
</li>
<li>Use the &#x27;IFileSystem&#x27; instance for file system operations.<!-- -->
<ul>
<li>(i.e. ISystemManagement.FileSystem)<br><br></li>
</ul>
</li>
<li>Use the &#x27;IDiskManager&#x27; instance for disk operations.<!-- -->
<ul>
<li>(i.e. ISystemManagement.DiskManager)<br><br></li>
</ul>
</li>
<li>Use the &#x27;IFirewallManager&#x27; instance for firewall operations.<!-- -->
<ul>
<li>(i.e. ISystemManagement.FirewallManager)<br><br></li>
</ul>
</li>
<li>Use the &#x27;IPackageManager&#x27; instance for package download, extraction and locating operations.<!-- -->
<ul>
<li>(i.e. ISystemManagement.PackageManager)<br><br></li>
</ul>
</li>
<li>Use the &#x27;ProcessManager&#x27; instance for operating system process creation and execution operations.<!-- -->
<ul>
<li>(i.e. ISystemManagement.ProcessManager)<br><br></li>
</ul>
</li>
<li>Use the &#x27;IStateManager&#x27; instance for local state preservation operations.<!-- -->
<ul>
<li>(i.e. ISystemManagement.StateManager)<br><br></li>
</ul>
</li>
<li>use the &#x27;PlatformSpecifics&#x27; instance for folder/file path creation/combining operations.<!-- -->
<ul>
<li>(i.e. ISystemManagement.PlatformSpecifics)</li>
</ul>
</li>
</ul>
<br>
<pre><code class="language-csharp">public class OpenSslExecutor : VirtualClientComponent
{
    public OpenSslExecutor(IServiceCollection dependencies, IDictionary&lt;string, IConvertible&gt; parameters)
    {
         // ISystemManagement has all shared/core dependencies.
         ISystemManagement systemManagement = dependencies.GetService&lt;ISystemManagement&gt;();
         IFileSystem fileSystem = systemManagement.FileSystem;
         IPackageManager packageManager = systemManagement.PackageManager;

         // Or...every interfaced instance on ISystemManagement is also available in the dependencies
         // supplied to every Virtual Client component constructor.
         IFileSystem fileSystem = dependencies.GetService&lt;IFileSystem&gt;();
         IPackageManager packageManager = dependencies.GetService&lt;IPackageManager&gt;();
    }
}
</code></pre>
</li>
<li>
<p><strong>Keep your components isolated from other components as much as possible</strong><br>
<!-- -->Each workload/test executor, monitor or dependency installers/handler should focus on one thing and do that well. By that definition, it is natural to assert that the logic within
that component should be isolated from other components. Over time the number of workload executors, monitors and dependency installers/handlers grows and it becomes harder
and harder to protect the runtime platform application from regressions and bugs. One way to help accomplish this this is to be methodical about how code for one component
can affect another component. If the 2 components do not share any code, then it is much less likely that a regression or bug in 1 of them causes the same in the other. The
shared/core dependencies exist to make this possible given the reality that very little code in an application can be 100% isolated. However, we purposefully minimize the shared
code between components. We instead harden the shared/core dependencies and enforce their use within workload/test executors, monitors and dependencies. The following are a
few examples of how you keep your components isolated.</p>
<ul>
<li>
<p>Avoid shared base classes in your components beyond the base &#x27;VirtualClientComponent&#x27; class.</p>
</li>
<li>
<p>Contrary to what you may have learned, do not try to make everything &quot;common/shared&quot; code just because a few components need the same thing. Common code paths represent
places where a single bug can break many things. Hence the bar for defining what makes something &quot;common&quot; must be kept high. As a general rule, common/shared code should be reserved
for logic that is used by at least 20% of all components within the platform/core. Keep the logic isolated in your own components until that point or until otherwise instructed.</p>
</li>
<li>
<p>Keep constants and enums defined within your component. Same as above, they are NOT common until demonstrably proven to be using the same general rule.</p>
</li>
</ul>
</li>
<li>
<p><strong>Keep your package names lower-cased</strong><br>
<!-- -->Windows paths, folder and file names are not case-sensitive. However on Unix/Linux they are. Packages are often downloaded to the system by the Virtual Client and then
referenced in code by path and by name. To make cross-platform coding easier, just keep the package names lower-cased because this will work on both operating system
platforms. This includes the name of the package file itself (e.g. diskspd.1.2.3.zip -&gt; package name = diskspd).</p>
</li>
<li>
<p><strong>Keep the names of any folder or files created programmatically lower-cased</strong><br>
<!-- -->For the same reason as the bullet point above, it is best to keep any programmatically created folder or file names lower-cased.</p>
</li>
<li>
<p><strong>Use the PlatformSpecifics.Combine() instead of Path.Combine() for referencing or combining paths</strong><br>
<!-- -->Do not use Path.Combine(). Use ISystemManagement.PlatformSpecifics.Combine() instead. Virtual Client operates on both Windows and Unix/Linux systems. The format of paths on these two operating system platforms differs.
On Windows backslashes are used (e.g. C:\any\path\to\something). On Unix/Linux forward slashes are used (e.g. /home/user/any/path/to/something).
Whereas the .NET framework typically handles combining paths (e.g. Path.Combine), do not use this in the code. Related to the bullet point above
on unit tests, this allows tests to be written that can target either Windows or Unix/Linux that can be ran on a Windows system for example while
maintaining the semantics of the other platform. This is especially important for testing components that run on either Windows or Unix/Linux.</p>
</li>
<li>
<p><strong>Always add useful context information to telemetry events/event context</strong><br>
<!-- -->The Virtual Client emits a lot of very good telemetry and this is very helpful especially for cases were debugging after it has ran is necessary. The best way to help
a user with debugging issues is to ensure proper context-specific information is included in the telemetry events emitted. All Virtual Client components emit telemetry
and are passed an &#x27;EventContext&#x27; object from the base VirtualClientComponent class. This object allows the developer to add additional context to the telemetry that will
be emitted. Imagine you will have to debug a problem. What information would be helpful? Include that type of information in the context.</p>
<pre><code class="language-csharp">// For example:
// It is usefult to capture context-specific information related to a process being executed 
// (the command, arguments, exit codes, standard output, standard error etc...)
EventContext relatedContext = telemetryContext.Clone()
    .AddContext(&quot;command&quot;, workload.Command)
    .AddContext(&quot;commandArguments&quot;, workload.CommandArguments);

return this.Logger.LogMessageAsync($&quot;{nameof(FioExecutor)}.ExecuteProcess&quot;, relatedContext, async () =&gt;
{
   try
   {
       using (IProcessProxy process = this.processManager.CreateProcess(pathToExe, commandLineArguments))
       {
          await process.StartAndWaitAsync(cancellationToken).ConfigureAwait(false);
          if (!cancellationToken.IsCancellationRequested)
          {
              // Capture the process outcome details
              this.Logger.LogWorkloadProcessDetails&lt;OpenSslExecutor&gt;(process, relatedContext);

              process.ThrowIfErrored&lt;WorkloadException&gt;(ProcessProxy.DefaultSuccessCodes, errorReason: ErrorReason.WorkloadFailed);
          }
       }
   }
   catch (Exception exc)
   {
       // Always capture unexpected exception/error information
       relatedContext.AddError(exc);
       throw;
   }
});
</code></pre>
</li>
<li>
<p><strong>Throw useful exceptions</strong><br>
<!-- -->Whenever developing new components, there will be certain scenarios that can happen where exceptions are explicitly thrown. Exceptions represent cases where
a set of expectations required for the application to run correctly cannot be met. This is such an important aspect of programming in the Virtual Client that
it has its own developer guidance documentation. Follow the recommendations in the documentation to ensure high quality exceptions and error information is
always provided to users of the Virtual Client.</p>
<ul>
<li><a href="/VirtualClient/docs/developing/0070-error-handling">Virtual Client Error Handling Developer Guide</a></li>
</ul>
</li>
</ul>
<h2 id="general-code-flow">General Code Flow</h2>
<p>The following section provides information on the general flow of the code for a Virtual Client component. This is helpful to understand when developing new
components for the platform.</p>
<h4 id="the-component-base-class">The Component Base Class</h4>
<p>Firstly, all components in the Virtual Client whether action, monitor or dependency handler derive/inherit from the base class <strong>VirtualClientComponent</strong>. Thus, when
implementing any new components, the developer should inherit from this class. The base class has a single constructor that must be implemented in the
new component class.</p>
<pre><code class="language-csharp">public class CustomWorkloadExecutor : VirtualClientComponent
{
    public CustomWorkloadExecutor(IServiceCollection dependencies, IDictionary&lt;string, IConvertible&gt; parameters = null)
        : base(dependencies, parameters)
    {
    }
}
</code></pre>
<p>This constructor takes in the following parameters:</p>
<ul>
<li>
<p><strong>IServiceCollection</strong><br>
<!-- -->Provides all shared/common dependencies required by Virtual Client components (see section above). These core dependencies can be used to interoperate
with the Virtual Client core runtime platform as well as the system on which it is running.</p>
</li>
<li>
<p><strong>IDictionary&lt;string, IConvertible&gt;</strong><br>
<!-- -->Provides the parameters defined in the profile for the action, monitor or dependency handler step to the class instance.</p>
</li>
</ul>
<h4 id="component-codemethod-flow">Component Code/Method Flow</h4>
<p>The following methods are executed in the order specified for each and every component in the Virtual Client platform. Of the methods listed, only the ExecuteAsync
method is required to be implemented. The other methods are optional and may be overridden in the new component to meet the needs of the developer implementation.</p>
<ul>
<li>
<p><strong>IsSupported</strong><br>
<!-- -->Method is executed to determin whether or not the component should be executed on the system. Reasons why a component might not be valid/supported
for a given system include:</p>
<ul>
<li>The component or its dependencies cannot run on the current platform/architecture (e.g. win-arm64, linux-arm64).</li>
<li>The component or its dependencies cannot run on the current distro of the operating system (e.g. Ubuntu, Redhat).</li>
</ul>
</li>
<li>
<p><strong>InitializeAsync</strong><br>
<!-- -->Method allows the developer to perform initial/preliminary validations and to set local member variables/properties that will be used when the
component ExecuteAsync() method is called. Some common things that are implemented in this method include:</p>
<ul>
<li>Checks to ensure the component has the dependencies it needs to succeed (e.g. dependency packages, system settings)</li>
<li>Setting member variables on the class instance that can be used later during the ExecuteAsync() call.</li>
</ul>
</li>
<li>
<p><strong>Validate</strong><br>
<!-- -->Method allows the developer to validate the component and parameters that were passed to the component in the constructor. This happens after
the initialization step to allow for any parameters that have &quot;calculated&quot; or replacement values to be evaluated. The developer should call the
&quot;EvaluateParametersAsync&quot; method to apply any well-known placeholders to the parameters. See the documentation on <a href="https://microsoft.github.io/VirtualClient/docs/guides/0011-profiles/">profiles</a>
for more information on parameter references and well-known parameter values.</p>
</li>
<li>
<p><strong>ExecuteAsync</strong><br>
<!-- -->Method is where the developer should perform the main body of work for the component. For example, this method may execute a workload binary
or test on the system. Additionally, this is the step where measurements/metrics captured from running workload or script binaries are parsed
and captured.</p>
</li>
<li>
<p><strong>CleanupAsync</strong><br>
<!-- -->Method allows the developer to perform any cleanup operations. For example, certain workload binaries leave log files as output on the file system.
It is a good idea to always cleanup any artifacts created during the operation of the component. This helps to ensure idempotency with components that
run in the Virtual Client runtime.</p>
</li>
</ul>
<h2 id="trace-logging-and-telemetry">Trace Logging and Telemetry</h2>
<p>All logging in the Virtual Client is telemetry. Telemetry differs from traditional free-form logging because it is typically more highly structured. Even trace
logging in the Virtual Client is structured telemetry. When writing code in the Virtual Client, a few different extension methods are provided that should be used to ensure that
logging is routed correctly. There are 3 different categories of telemetry in the Virtual Client each with its own logging extension method(s).</p>
<ul>
<li>
<p><strong>Trace Logs Telemetry</strong><br>
<!-- -->This category includes seneric application trace messages. These are used primarily for debugging purposes make it easy for the user to see exactly what the application is
doing. Trace messages are especially important for situations where operations are failing in the Virtual Client. In most cases, errors are automatically captured by the
logging mechanics of the Virtual Client. Having the error messages and callstack available is very helpful for determining root causes of issues.</p>
<p>There are 2 different levels of importance for trace messages in the Virtual Client. A &quot;trace message&quot; will always be LogLevel.Trace. These messages are typically used for
verbose output and will display in the console output ONLY when the &quot;--debug&quot; flag is used on the command line.</p>
<pre><code class="language-csharp">this.Logging.LogTraceMessage($&quot;AnyComponent.PerformOperation&quot;, telemetryContext);

// A corresponding asynchronous method implementation exists as well.
await this.Logging.LogTraceMessageAsync($&quot;AnyComponent.PerformOperation&quot;, telemetryContext)
    .ConfigureAwait(false);
</code></pre>
<p>The second type of trace message is the application informational message. The messages are typically LogLevel.Information but may be any log level. This type of trace message
is always output to console output and to other targets.</p>
<pre><code class="language-csharp">this.Logging.LogMessage($&quot;AnyComponent.PerformOperation&quot;, LogLevel.Information, telemetryContext);
this.Logging.LogMessage($&quot;AnyComponent.SomeTypeOfError&quot;, LogLevel.Error, telemetryContext);

// A corresponding asynchronous method implementation exists as well.
await this.Logging.LogMessageAsync($&quot;AnyComponent.PerformOperation&quot;, LogLevel.Information, telemetryContext)
    .ConfigureAwait(false);

// Error information is easy to capture as well using this logging extension method.
try
{
     // Some kind of logic that could result in exceptions happening.
}
catch (Exception exc)
{
    this.Logging.LogMessage(&quot;AnyComponent.SomeOperationError&quot;, LogLevel.Error, telemetryContext.AddError(exc));
}
</code></pre>
<p>The developer will often see a particular LogMessage/LogMessageAsync extension method being used that wraps an entire block of
code. This extension provides additional functionality desirable when logging information including capturing the time (in milliseconds)
that the logic in the block of code took to execute and automatically handling + capturing error information.</p>
<pre><code class="language-csharp">return this.Logging.LogMessageAsync($&quot;AnyComponent.PerformOperation&quot;, telemetryContext, async () =&gt;
{
    // A block of 1 or more lines of code inside of here to perform some set of operations.
    // This logging extension provides some nice features around logging:
    //
    // 1) A &quot;Start&quot; event is written capturing a timestamp at the beginning of the logic block operations
    //   (e.g. AnyComponent.PerformOperationStart).
    //
    // 2) A &quot;Stop&quot; event is written capturing a timestamp at the end of the logic block operations (e.g. AnyComponent.PerformOpertionStop). 
    //    This event will contain a propery &#x27;durationMs&#x27; in the telemetry message context/custom dimensions that defines the length of
    //    time in milliseconds the logic took. This can be helpful when analyzing the performance of logic later on
    //    without needing to perform date/time math.
    //
    // 3) Any exceptions/errors that are throw will be automatically captured and the error messages + callstack will be added to
    //    an &quot;Error&quot; message (e.g. AnyComponent.PerformOpertionError).
    //
    // All of this functionality is wrapped up in the extension method which allows for consistency in telemetry event names and
    // error handling while significantly reducing &quot;noise&quot; in the code related to telemetry logic.
});
</code></pre>
<p>The Virtual Client framework additionally has a logging extension method for cases where the developer wants to treat exceptions/errors as
traditional free-form logging vs. structured logging.</p>
<pre><code class="language-csharp">try
{
     // Some kind of logic that could result in exceptions happening.
}
catch (Exception exc)
{
    this.Logging.LogErrorMessage(exc, telemetryContext);
}

</code></pre>
</li>
<li>
<p><strong>Metrics/Measurements Telemetry</strong><br>
<!-- -->One of the primary goals of the Virtual Client runtime is to capture and structure metrics/measurements from the output of workloads, tests
and monitors. To ensure consistency in the structure of metrics/measurements, a logging extension method is provided for the purpose.</p>
<pre><code class="language-csharp">private void CaptureMetrics(IProcessProxy process, DateTime startTime, DateTime endTime, EventContext telemetryContext)
{
    string workloadResults = process.StandardOutput.ToString();
    ExampleWorkloadMetricsParser resultsParser = new ExampleWorkloadMetricsParser(workloadResults);
    IList&lt;Metric&gt; workloadMetrics = resultsParser.Parse();

    this.Logger.LogMetrics(
        toolName: &quot;ExampleWorkload&quot;,
        scenarioName: &quot;some_unique_scenario_for_the_workload&quot;,
        scenarioStartTime: startTime,
        scenarioEndTime: endTime,
        metrics: workloadMetrics,
        metricCategorization: null,
        scenarioArguments: &quot;ExampleWorkload.exe --any=command --line=arguments&quot;,
        this.Tags,
        telemetryContext);
}
</code></pre>
</li>
<li>
<p><strong>System Events Telemetry</strong><br>
<!-- -->The Virtual Client also has a logging extension designed for capturing important information or events from the system on which it is running. This extension
allows the developer to capture this information and to ensure it is routed together for distinction in telemetry storage resources.</p>
<pre><code class="language-csharp">// The only requirement for the dictionary values (e.g. the object instances) is that
// it is JSON-serializable.
IDictionary&lt;string, object&gt; eventLogEntries = this.GetEventLogEntries(eventId: 21);
this.Logger.LogSystemEvents(&quot;AnyMonitor.CaptureEventLogs&quot;, eventLogEntries, telemetryContext)
</code></pre>
</li>
<li>
<p><strong>Metadata Contract</strong>
The Virtual Client framework provides a simple model for enabling developers to impart a &quot;metadata contract&quot; in the telemetry that is output from
the application. The metadata contract facilitates a consistent schema within telemetry events to include context information about the host, operating system,
hardware and workload/monitor scenarios. In fact certain information about the host, operating system, hardware and profile workload/monitor is included in
the output of the Virtual Client by default.</p>
<ul>
<li>
<p><a href="/VirtualClient/docs/guides/0040-telemetry">Metadata Contract Details and Examples</a><br>
<!-- -->Familiarize yourself with the different categories of metadata available (e.g. default, dependencies, host, runtime, scenario).</p>
</li>
<li>
<p>Persisted/Global Metadata<br>
<!-- -->The metadata contract feature allows users to persist metadata that will be included with the telemetry emitted by every
component within a Virtual Client profile (e.g. actions, monitors, and dependencies). Persisted metadata will be combined with
component-specific metadata (described below) when emitting telemetry within that component.</p>
<pre><code class="language-csharp"> // Persist metadata properties throughout the entire execution runtime of the Virtual Client.
 MetadataContract.Persist(&quot;company&quot;, &quot;Microsoft&quot;, MetadataContractCategory.Default);
 MetadataContract.Persist(&quot;package_openssl&quot;, &quot;openssl.3.0.0.zip&quot;, MetadataContractCategory.Dependencies);
 MetadataContract.Persist(&quot;hostType&quot;, &quot;Physical Blade&quot;, MetadataContractCategory.Host);
 MetadataContract.Persist(&quot;&quot;, &quot;Microsoft&quot;, MetadataContractCategory.Runtime);
 MetadataContract.Persist(&quot;category&quot;, &quot;CPU Performance&quot;, MetadataContractCategory.Scenario);
</code></pre>
</li>
<li>
<p>Component-Specific Metadata<br>
<!-- -->The metadata contract feature supports the ability for the developer to define information specific to a given component within a Virtual Client
profile. This metadata is merged with the persisted/global metadata described above and emitted with the telemetry for the specific component.</p>
<pre><code class="language-csharp"> // Each component within Virtual Client has a &quot;MetadataContract&quot; property to which the developer can add metadata specific to the
 // execution context of that component at runtime (e.g. OpenSslExecutor).
 this.MetadataContract.Add(&quot;company&quot;, &quot;Microsoft&quot;, MetadataContractCategory.Default);
 this.MetadataContract.Add(&quot;package_openssl&quot;, &quot;openssl.3.0.0.zip&quot;, MetadataContractCategory.Dependencies);
 this.MetadataContract.Add(&quot;hostType&quot;, &quot;Physical Blade&quot;, MetadataContractCategory.Host);
 this.MetadataContract.Add(&quot;&quot;, &quot;Microsoft&quot;, MetadataContractCategory.Runtime);
 this.MetadataContract.Add(&quot;category&quot;, &quot;CPU Performance&quot;, MetadataContractCategory.Scenario);
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="telemetry-loggers">Telemetry Loggers</h2>
<p>The Virtual Client uses a set of different types of loggers each implementing the .NET ILogger interface:</p>
<ul>
<li>
<p><strong>Console Logger</strong><br>
<!-- -->Used to write telemetry messages to the console standard output and error streams (e.g. on-screen logging). Verbose output on-screen is enabled in the
Virtual Client by supplying the &quot;--debug&quot; flag on the command line.</p>
</li>
<li>
<p><strong>File Logger</strong><br>
<!-- -->Used to write telemetry messages to log files. Virtual Client writes 3 different types of log files that can all be found in the application &quot;logs&quot; directory.
The 3 different log files include those that contain general trace logging and messages, those that include workload and system metrics information only and those that
contain system performance counter measurements and information.</p>
</li>
<li>
<p><strong>Event Hub Logger</strong><br>
<!-- -->Used to upload telemetry messages to an Azure Event Hubs namespace. In practice the Virtual Client uses 3 or 4 different Event Hubs within the namespace to section
off the data by its category (e.g. traces vs. metrics). Azure provides out-of-box support for a number of different &quot;big data&quot; storage resources that can ingest the telemetry
from the Event Hubs into storage. For example the VC Team connects Azure Data Explorer/Kusto clusters to the Event Hub so that the telemetry emitted to the Event Hub is being
automatically ingested into the cluster databases.</p>
</li>
</ul>
<h2 id="code-examples">Code Examples</h2>
<p>Sometimes the very best documentation for developers to learn is hands-on coding. The VC Team has included a set of code examples that illustrate some of the
implementation concepts. Good news! If you are at this point, your manager can no longer give you a hard time talking about &quot;implementation details&quot;.
The devil is in them from this point forward, so enjoy!! :) Each of the examples below can be ran right at the developer desktop for breakpoint/debugging
euphoria. We typically use the Visual Studio IDE due to its robust support for developer &quot;inner-loop&quot; needs.</p>
<ul>
<li>
<p><strong>Example Implementations</strong><br>
<!-- -->The following examples illustrate some of the basic implementation concepts for Virtual Client workload/test executors and monitors. These examples are
used in an example workload profile. The examples can be run at the desktop within Visual Studio for live debugging.</p>
<ul>
<li>
<p><a href="https://github.com/microsoft/VirtualClient/blob/main/src/VirtualClient/VirtualClient.Main/profiles/EXAMPLE-WORKLOAD.json">Example Workload + Monitoring Profile</a><br>
<!-- -->This profile references the example workload executor below as well as the example monitor. This profile also has a dependency installer/handler in it
to download a workload package from a blob store. This profile can be run at the desktop to see how things work. Note that you will need a SAS URI to the
VC Team storage account where the workload packages exist. Virtual Client will be downloading dependency packages from here. Contact the VC Team to get
a SAS URI for your needs.</p>
<ul>
<li>To Debug: In Visual Studio:<!-- -->
<ul>
<li>Set the &#x27;VirtualClient.Main&#x27; project as the &#x27;Startup project&#x27;.</li>
<li>Right-click on this project and select &#x27;Properties&#x27; from the menu.</li>
<li>In the &#x27;Debug&#x27; section, put the following in for the &#x27;Application arguments&#x27;:<!-- -->
<ul>
<li>--profile=EXAMPLE-WORKLOAD.json --timeout=1440 --packages=&lt;YourBlobStoreSASUri&gt;</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="https://github.com/microsoft/VirtualClient/blob/main/src/VirtualClient/VirtualClient.Actions/Examples/ExampleWorkloadExecutor.cs">Example Workload/Test Executor</a><br>
<!-- -->Provides a coded example for how to write a basic workload executor.</p>
</li>
<li>
<p><a href="https://github.com/microsoft/VirtualClient/blob/main/src/VirtualClient/VirtualClient.Monitors/ExampleProfilingMonitor.cs">Workload/Test Executor and Background Profiling Monitor</a><br>
<!-- -->Provides a coded example of how to write a monitor that can be used for background profiling operations (both Interval-based as well as On-Demand).</p>
</li>
<li>
<p><a href="https://github.com/microsoft/VirtualClient/blob/main/src/VirtualClient/VirtualClient.Actions/Examples/ClientServer">Example Client/Server Executor</a><br>
<!-- -->Provides a coded example for how to write advanced, client/server workload executors.</p>
</li>
</ul>
</li>
<li>
<p><strong>Examples of Unit Tests</strong><br>
<!-- -->The following examples illustrate some of the unit testing concepts in the Virtual Client codebase.</p>
<ul>
<li>
<p><a href="https://github.com/microsoft/VirtualClient/blob/main/src/VirtualClient/VirtualClient.Actions.UnitTests/Example2WorkloadExecutor.cs">Example Action/Executor</a></p>
</li>
<li>
<p><strong>Example Tests using MockFixture</strong><br>
<!-- -->Provides examples of basic unit testing concepts along with the use of the MockFixture helper class.</p>
<ul>
<li><a href="https://github.com/microsoft/VirtualClient/blob/main/src/VirtualClient/VirtualClient.Actions.UnitTests/Example2WorkloadExecutorTests_MockFixture.cs">Example Tests</a></li>
</ul>
</li>
<li>
<p><strong>Example Tests using DependencyFixture</strong><br>
<!-- -->Provides examples of basic unit testing concepts along with the use of the DependencyFixture helper class. This class differs from the MockFixture
in that it uses in-memory implementations of the Virtual Client platform core dependencies. It is typically used for functional testing in Virtual Client
projects.</p>
<ul>
<li><a href="https://github.com/microsoft/VirtualClient/blob/main/src/VirtualClient/VirtualClient.Actions.UnitTests/Example2WorkloadExecutorTests_DependencyFixture.cs">Example Tests</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="debugging-virtual-client-code">Debugging Virtual Client Code</h2>
<p>The sections below document some of the ways in which the developer can debug components in the Virtual Client. The Visual Studio IDE is used for these examples because of its
robust support for developer inner-loop processes including support for debugging.</p>
<h4 id="debug-in-visual-studio-using-unitfunctional-tests">Debug in Visual Studio Using Unit/Functional Tests</h4>
<p>There is no faster way to get a debugger attached to your code than via an Nunit test. The Visual Studio &#x27;Test Explorer&#x27; makes it very
easy to put a break point in the code of a test method, to right-click in the test and then to select &#x27;Debug Test(s)&#x27; from the context
menu. From that point Visual Studio will build your source code and will execute the test with a debugger attached. The VC Team often
has 3 different types of test projects in source (i.e. unit, functional, integration) that are used for testing the code with various
goals and these are all just as easy to use for debugging purposes.</p>
<p>Once you have written a unit/functional test in Visual Studio:</p>
<ul>
<li>Place a breakpoint at the beginning of the test method.</li>
<li>Right-click in the test.</li>
<li>Select &quot;Debug Test(s)&quot; from the context menu.</li>
</ul>
<p>Visual Studio will build the source code, attach a debugger to the test execution runner and will run the test code. The debugger will hit your breakpoint in the test. From that
point forward, you can step through your code as normal (e.g. F5, F10, F11 debug stepping).</p>
<h4 id="debug-in-visual-studio-by-running-a-custom-profile">Debug in Visual Studio by Running a Custom Profile</h4>
<p>The developer may sometimes want to run the full Virtual Client runtime executable to debug his/her code. This is often the case when the developer wants to test the code live and
without any mocks. To do this, it is easiest to create a custom profile in a directory on the file system that contains actions, monitors, dependencies definitions related to the class
the developer wants to debug. If the profile is for debugging purposes only, it is best to create it in a directory outside of source control and to place ONLY the components
in the profile required for correct operations. For example, the developer may be creating a new action/workload executor and wants to test it. This action/workload executor may
require a dependency package exist or be downloaded at runtime. The developer can either place the dependency package in the build output directory for the Virtual Client or can
put an appropriate DependencyPackageInstallation component in the profile so that it can be downloaded (assuming the dependency package exists in the package store). The following
examples illustrate how to do this.</p>
<ul>
<li>
<p><strong>Custom Profile Option #1</strong><br>
<!-- -->In this example, a custom profile will be used to debug an action/executor on which the developer is working (e.g. ExampleWorkloadExecutor below). This action/executor requires
a specific dependency package containing workload binaries to be downloaded. A custom profile will be used to incorporate the action/executor and the workload dependency package.</p>
<pre><code class="language-json"># A custom profile is created and placed on the file system somewhere (typically somewhere outside of the source directory). In this profile, the
# custom action/executor component is added to the actions and the dependency package installation component is added to the dependencies.
{
  &quot;Description&quot;: &quot;Debug Example Workload Executor&quot;,
  &quot;Actions&quot;: [
      {
          &quot;Type&quot;: &quot;ExampleWorkloadExecutor&quot;,
          &quot;Parameters&quot;: {
              &quot;Scenario&quot;: &quot;Scenario1&quot;,
              &quot;CommandLine&quot;: &quot;Workload duration=00:01:00&quot;,
              &quot;ExampleParameter1&quot;: &quot;AnyValue1&quot;,
              &quot;ExampleParameter2&quot;: 4567,
              &quot;PackageName&quot;: &quot;exampleworkload&quot;,
              &quot;Tags&quot;: &quot;Test,VC&quot;
          }
      }
  ],
  &quot;Dependencies&quot;: [
      {
          &quot;Type&quot;: &quot;DependencyPackageInstallation&quot;,
          &quot;Parameters&quot;: {
              &quot;Scenario&quot;: &quot;InstallExampleWorkloadPackage&quot;,
              &quot;BlobContainer&quot;: &quot;packages&quot;,
              &quot;BlobName&quot;: &quot;exampleworkload.1.0.0.zip&quot;,
              &quot;PackageName&quot;: &quot;exampleworkload&quot;,
              &quot;Extract&quot;: true
          }
      }
  ]
}
</code></pre>
<p>Once the profile is created, setup Visual Studio for debugging</p>
<ol>
<li>Set the solution configuration to <strong>Debug</strong> at the top of the Visual Studio IDE window.</li>
<li>Set the <strong>VirtualClient.Main</strong> project as the startup project. To do so, right-click on the project in the Solution Explorer and select
<strong>Set as Startup Project</strong> from the context menu.</li>
<li>Right-click on the VirtualClient.Main project and open the <strong>Debug</strong> options. Set the following information.<!-- -->
<ul>
<li>Application arguments =<code>--profile={PathToCustomProfile} --profile=MONITORS-NONE.json --packages=&quot;{PackageStoreConnectionString|SASUri}&quot;</code>.<br>
<!-- -->(e.g. <code>--profile=S:\one\debugging\DEBUG-EXAMPLE-WORKLOAD.json --profile=MONITORS-NONE.json --packages=&quot;https://virtualclient...&quot;</code>)</li>
</ul>
</li>
<li>Place a breakpoint in the code where you like (e.g. in the InitializeAsync or ExecuteAsync methods of your component).</li>
<li>Click the play/continue button at the top-center of the Visual Studio IDE window (or press the F5 key).</li>
</ol>
</li>
<li>
<p><strong>Custom Profile Option #2</strong><br>
<!-- -->This option is the same as option #1 above except that the developer will copy the workload dependency package to the appropriate directory in the
Virtual Client build output directory ahead of time. Once the package is in this directory, the Virtual Client does not need to download it and thus
the custom profile can be simplified by removing the &quot;Dependencies&quot; section as illustrated below.</p>
<pre><code class="language-json"># A custom profile is created and placed on the file system somewhere (typically somewhere outside of the source directory). In this profile, the
# custom action/executor component is added to the actions.
{
  &quot;Description&quot;: &quot;Debug Example Workload Executor&quot;,
  &quot;Actions&quot;: [
      {
          &quot;Type&quot;: &quot;ExampleWorkloadExecutor&quot;,
          &quot;Parameters&quot;: {
              &quot;Scenario&quot;: &quot;Scenario1&quot;,
              &quot;CommandLine&quot;: &quot;Workload duration=00:01:00&quot;,
              &quot;ExampleParameter1&quot;: &quot;AnyValue1&quot;,
              &quot;ExampleParameter2&quot;: 4567,
              &quot;PackageName&quot;: &quot;exampleworkload&quot;,
              &quot;Tags&quot;: &quot;Test,VC&quot;
          }
      }
  ]
}
</code></pre>
<p>The workload dependencies package must be copied into the <strong>{repo_directory}/out/bin/Debug/x64/VirtualClient.Main/packages</strong>
directory before beginning to debug.</p>
<pre><code>e.g.
S:\one\virtualclient\out\bin\Debug\VirtualClient.Main\packages\exampleworkload.1.0.0.zip
</code></pre>
<p>Once the profile is created, setup Visual Studio for debugging</p>
<ol>
<li>Set the solution configuration to <strong>Debug</strong> at the top of the Visual Studio IDE window.</li>
<li>Set the <strong>VirtualClient.Main</strong> project as the startup project. To do so, right-click on the project in the Solution Explorer and select
<strong>Set as Startup Project</strong> from the context menu.</li>
<li>Right-click on the VirtualClient.Main project and open the <strong>Debug</strong> options. Set the following information.<!-- -->
<ul>
<li>Application arguments = <code>--profile={PathToCustomProfile} --profile=MONITORS-NONE.json</code>.<br>
<!-- -->(e.g. <code>--profile=S:\one\debugging\DEBUG-EXAMPLE-WORKLOAD.json --profile=MONITORS-NONE.json</code>)</li>
</ul>
</li>
<li>Place a breakpoint in the code where you like (e.g. in the InitializeAsync or ExecuteAsync methods of your component).</li>
<li>Click the play/continue button at the top-center of the Visual Studio IDE window (or press the F5 key).</li>
</ol>
</li>
<li>
<p><strong>Custom Profile Option #3</strong><br>
<!-- -->This option is the same as option #2 above except that we will set an environment variable to the path/directory location of the workload dependency
package on the system.</p>
<pre><code class="language-json"># A custom profile is created and placed on the file system somewhere (typically somewhere outside of the source directory). In this profile, the
# custom action/executor component is added to the actions.
{
  &quot;Description&quot;: &quot;Debug Example Workload Executor&quot;,
  &quot;Actions&quot;: [
      {
          &quot;Type&quot;: &quot;ExampleWorkloadExecutor&quot;,
          &quot;Parameters&quot;: {
              &quot;Scenario&quot;: &quot;Scenario1&quot;,
              &quot;CommandLine&quot;: &quot;Workload duration=00:01:00&quot;,
              &quot;ExampleParameter1&quot;: &quot;AnyValue1&quot;,
              &quot;ExampleParameter2&quot;: 4567,
              &quot;PackageName&quot;: &quot;exampleworkload&quot;,
              &quot;Tags&quot;: &quot;Test,VC&quot;
          }
      }
  ]
}
</code></pre>
<p>The workload dependencies package exists in a directory on the system already. We set an environment variable <strong>VCDependenciesPath</strong> to this path/directory location
before beginning to debug.</p>
<pre><code>e.g.

# Workload dependency package exists in a folder on the file system. We will set the &#x27;VCDependenciesPath&#x27; environment variable to this
# location.
S:\one\debugging\packages\exampleworkload.1.0.0.zip
</code></pre>
<p>Once the profile is created, setup Visual Studio for debugging</p>
<ol>
<li>Set the solution configuration to <strong>Debug</strong> at the top of the Visual Studio IDE window.</li>
<li>Set the <strong>VirtualClient.Main</strong> project as the startup project. To do so, right-click on the project in the Solution Explorer and select
<strong>Set as Startup Project</strong> from the context menu.</li>
<li>Right-click on the VirtualClient.Main project and open the <strong>Debug</strong> options. Set the following information.<!-- -->
<ul>
<li>Application arguments = <code>--profile={PathToCustomProfile}</code>.<br>
<!-- -->(e.g. <code>--profile=S:\one\debugging\DEBUG-EXAMPLE-WORKLOAD.json --profile=MONITORS-NONE.json</code>)</li>
<li>Environment variables = Add the <code>VCDependenciesPath</code> variable and the path to your package directory.<br>
<!-- -->(e.g. <code>VCDependenciesPath = S:\one\debugging\packages</code>)</li>
</ul>
</li>
<li>Place a breakpoint in the code where you like (e.g. in the InitializeAsync or ExecuteAsync methods of your component).</li>
<li>Click the play/continue button at the top-center of the Visual Studio IDE window (or press the F5 key).</li>
</ol>
</li>
</ul></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/microsoft/VirtualClient/edit/main/website/docs/developing/0010-develop-guide.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_vwxv"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/VirtualClient/docs/developing/0001-ci-cd/"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Automated Build and CI/CD pipeline</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/VirtualClient/docs/developing/0020-develop-extensions/"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Developing Extensions</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#preliminaries" class="table-of-contents__link toc-highlight">Preliminaries</a></li><li><a href="#terminology" class="table-of-contents__link toc-highlight">Terminology</a></li><li><a href="#practices-and-principles" class="table-of-contents__link toc-highlight">Practices and Principles</a></li><li><a href="#considerations-when-getting-started" class="table-of-contents__link toc-highlight">Considerations When Getting Started</a></li><li><a href="#platformcore-projects-and-libraries" class="table-of-contents__link toc-highlight">Platform/Core Projects and Libraries</a></li><li><a href="#virtualclientcomponent" class="table-of-contents__link toc-highlight">VirtualClientComponent</a></li><li><a href="#commonshared-dependencies" class="table-of-contents__link toc-highlight">Common/Shared Dependencies</a></li><li><a href="#coding-practices" class="table-of-contents__link toc-highlight">Coding Practices</a></li><li><a href="#general-code-flow" class="table-of-contents__link toc-highlight">General Code Flow</a></li><li><a href="#trace-logging-and-telemetry" class="table-of-contents__link toc-highlight">Trace Logging and Telemetry</a></li><li><a href="#telemetry-loggers" class="table-of-contents__link toc-highlight">Telemetry Loggers</a></li><li><a href="#code-examples" class="table-of-contents__link toc-highlight">Code Examples</a></li><li><a href="#debugging-virtual-client-code" class="table-of-contents__link toc-highlight">Debugging Virtual Client Code</a></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/VirtualClient/docs/overview/">Overview</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/microsoft/VirtualClient/discussions" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discussion<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/VirtualClient/blog/">Blog</a></li><li class="footer__item"><a href="https://github.com/microsoft/VirtualClient" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="margin-bottom--sm"><a href="https://microsoft.com/" rel="noopener noreferrer" class="footerLogoLink_BH7S"><img src="/VirtualClient/img/microsoft-logo-white-text.svg" alt="MSFT Logo" class="footer__logo themedComponent_mlkZ themedComponent--light_NVdE"><img src="/VirtualClient/img/microsoft-logo-white-text.svg" alt="MSFT Logo" class="footer__logo themedComponent_mlkZ themedComponent--dark_xIcU"></a></div><div class="footer__copyright">Copyright © 2024 Microsoft.</div></div></div></footer></div>
</body>
</html>