"use strict";(self.webpackChunkvirtualclient=self.webpackChunkvirtualclient||[]).push([[1515],{1582:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>p,frontMatter:()=>o,metadata:()=>a,toc:()=>c});var s=t(4848),i=t(8453);const o={},r="Developing Script Extensions",a={id:"developing/0021-develop-script-extensions",title:"Developing Script Extensions",description:"The use of scripting languages (e.g. Python, PowerShell) is a popular choice for software and system engineers responsible for automating test coverage",source:"@site/docs/developing/0021-develop-script-extensions.md",sourceDirName:"developing",slug:"/developing/0021-develop-script-extensions",permalink:"/VirtualClient/docs/developing/0021-develop-script-extensions",draft:!1,unlisted:!1,editUrl:"https://github.com/microsoft/VirtualClient/edit/main/website/docs/developing/0021-develop-script-extensions.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Developing Extensions",permalink:"/VirtualClient/docs/developing/0020-develop-extensions"},next:{title:"Workload Onboarding Process",permalink:"/VirtualClient/docs/developing/0030-workload-onboarding"}},l={},c=[{value:"Script Extensions Usage",id:"script-extensions-usage",level:2},{value:"Integrating Script Extensions",id:"integrating-script-extensions",level:3},{value:"Executing Scripts in an Extensions Package",id:"executing-scripts-in-an-extensions-package",level:3},{value:"Script Extensions Design Principles",id:"script-extensions-design-principles",level:2},{value:"Script Extensions Implementation Guidelines",id:"script-extensions-implementation-guidelines",level:2},{value:"Script Extensions Packaging Guidelines",id:"script-extensions-packaging-guidelines",level:2}];function d(e){const n={a:"a",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"developing-script-extensions",children:"Developing Script Extensions"}),"\n",(0,s.jsx)(n.p,{children:"The use of scripting languages (e.g. Python, PowerShell) is a popular choice for software and system engineers responsible for automating test coverage\non bare metal hardware systems. The Virtual Client platform provides runtime support for running scripts directly from the command line and additionally\nsupports a controller/agent workflow for remote execution through SSH sessions on both Linux and Windows systems."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"/VirtualClient/docs/guides/0021-controller-agent",children:"Controller/Agent Overview"})}),"\n",(0,s.jsx)(n.p,{children:"The following document provides a set of general guidelines to consider when developing script-based automation extensions so that they can be readily integrated\ninto the Virtual Client platform."}),"\n",(0,s.jsx)(n.h2,{id:"script-extensions-usage",children:"Script Extensions Usage"}),"\n",(0,s.jsx)(n.p,{children:"Before going into the details for script extensions development, it is helpful to have an idea of how they can be used in the\nVirtual Client platform. The following sections illustrate how to integrate script packages into the Virtual Client platform for execution via the command line. Whereas the Virtual Client\nplatform often defines complex workflows using profiles, scripts can be executed directly without the need for a profile. Before getting into design and implementation\nrecommendations for script-based automation, it is helpful to get a sense of how they will be used in Virtual Client."}),"\n",(0,s.jsx)(n.h3,{id:"integrating-script-extensions",children:"Integrating Script Extensions"}),"\n",(0,s.jsxs)(n.p,{children:["A package/folder containing scripts can be placed anywhere on the system, but the recommendation is to place them in the ",(0,s.jsx)(n.code,{children:"/packages"})," folder for the Virtual Client\napplication. This is the folder that the application uses to download and host packages for all other toolsets."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# e.g.\n# Example On Windows Systems\nC:\\Users\\AnyUser\\VirtualClient\\content\\win-arm64\\packages\\custom_scripts.1.0.0\nC:\\Users\\AnyUser\\VirtualClient\\content\\win-arm64\\packages\\custom_scripts.1.0.0\\binaries\nC:\\Users\\AnyUser\\VirtualClient\\content\\win-arm64\\packages\\custom_scripts.1.0.0\\setup\nC:\\Users\\AnyUser\\VirtualClient\\content\\win-arm64\\packages\\custom_scripts.1.0.0\\Invoke-FirmwareUpdate.ps1\n\n# e.g.\n# Example On Linux Systems\n/home/anyuser/VirtualClient/content/linux-x64/packages/custom_scripts.1.0.0\n/home/anyuser/VirtualClient/content/linux-x64/packages/custom_scripts.1.0.0/binaries\n/home/anyuser/VirtualClient/content/linux-x64/packages/custom_scripts.1.0.0/setup\n/home/anyuser/VirtualClient/content/linux-x64/packages/custom_scripts.1.0.0/update_firmware.py\n"})}),"\n",(0,s.jsx)(n.h3,{id:"executing-scripts-in-an-extensions-package",children:"Executing Scripts in an Extensions Package"}),"\n",(0,s.jsx)(n.p,{children:"Scripts within a script extensions package/folder can be referenced and executed directly on the command line in Virtual Client. To reference\na script on the command line, the full script command should be surrounded in quotation marks."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'# e.g.\n# Windows Examples\n# Scripts can be referenced directly on the command line.\nVirtualClient.exe "pwsh C:\\Users\\AnyUser\\VirtualClient\\content\\win-arm64\\packages\\custom_scripts.1.0.0\\Invoke-FirmwareUpdate.ps1 -LogDirectory C:\\Users\\AnyUser\\VirtualClient\\content\\win-arm64\\logs\\firmware_updates"\n\n# Relative paths can be used as well and are relative to the Virtual Client application.\nVirtualClient.exe "pwsh .\\packages\\custom_scripts.1.0.0\\Invoke-FirmwareUpdate.ps1 -LogDirectory .\\logs\\firmware_updates"\n\n# e.g.\n# Linux Examples\nVirtualClient "python C:\\Users\\AnyUser\\VirtualClient\\content\\win-arm64\\packages\\custom_scripts.1.0.0\\update_firmware.py --log-directory=/home/anyuser/VirtualClient/content/linux-arm64/logs/firmware_updates"\n\n# Relative paths...\nVirtualClient "python ./packages/custom_scripts.1.0.0/update_firmware.py --log-directory=./logs/firmware_updates"\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Your scripts do not really even need to write log files. Virtual Client allows the user to request the output of any script or toolset ran from the command line\nto be written to file by simply including the ",(0,s.jsx)(n.code,{children:"--log-to-file"})," flag on the command line."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'# Windows Examples\nVirtualClient.exe "pwsh .\\packages\\custom_scripts.1.0.0\\Invoke-FirmwareUpdate.ps1 -LogDirectory .\\logs\\firmware_updates" --log-to-file\n\n# Linux Examples\nVirtualClient "python ./packages/custom_scripts.1.0.0/update_firmware.py --log-directory=./logs/firmware_updates" --log-to-file\n'})}),"\n",(0,s.jsx)(n.h2,{id:"script-extensions-design-principles",children:"Script Extensions Design Principles"}),"\n",(0,s.jsx)(n.p,{children:"The following section defines a set of recommendations to apply when designing script-based automation."}),"\n",(0,s.jsx)("div",{children:(0,s.jsx)("mark",{children:(0,s.jsxs)(n.p,{children:["A very fundamental concept to consider when designing scripted automation is to focus on creating ",(0,s.jsx)("b",{children:"self-contained packages"}),". Self-contained\npackages can be simply copied/downloaded to a target system and executed successfully with no additional steps. This makes debugging/testing and integration\nwith automation systems much more seamless. Manual steps are problematic for repeatable and efficient scale executions."]})})}),"\n",(0,s.jsx)("br",{}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Scripts Can be Executed Independently"}),(0,s.jsx)(n.br,{}),"\n","Scripts should be executable largely independent of other automation/orchestration systems. For example, a user should be\nable to copy/download the test content to a system and run it with very minimal (if any) additional requirements. It is acceptable for the scripted\nautomation to depend upon other libraries/modules or toolsets (a very common scenario in software/automation); however, these should be either included with the\nscript package itself or easily installable. Similarly, if installation is required, it is advisable to include additional scripted automation to handle this\nrequirement (e.g. scripts that install Linux packages)."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Scripts Can be Easily Integrated Into Scale Automation"}),(0,s.jsx)(n.br,{}),"\n","Scripts should be easy to integrate with scale automation/orchestration systems. In general, scripted automation SHOULD NOT\nbe dependent upon automation/orchestration systems to work correctly as this would be in conflict with the tenet noted above. Much of the process of designing\neasy-to-integrate script-based automation involves following command line 101 practices. Scripts designed as command line toolsets are typically easy to\nexecute either manually or in scale automation systems (unattended). They additionally allow required information to be easily provided to the application via\nthe command line or as environment variables. The latter two aspects are very common and easy to implement."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Scripts Should Produce Easy-to-Access Results"}),(0,s.jsx)(n.br,{}),"\n","Whether the script-based automation is executed by a user manually on a system or across 100s of systems by scale automation, the results should be easy\nto access. Useful information should be provided in the standard output and standard error of the terminal/console. Another common option is to emit the information\nto a file on the system (i.e. log file). This is not as easy to integrate as standard output/error but is acceptable."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"script-extensions-implementation-guidelines",children:"Script Extensions Implementation Guidelines"}),"\n",(0,s.jsx)(n.p,{children:"The following section applies the design principles noted above to some of the implementation details. These recommendations below aim at\nfacilitating the creation of lightweight script automation that is relatively easy to write."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Scripts Should be Written for Command Line Toolset/Terminal Integration"}),(0,s.jsx)(n.br,{}),"\n","There are few (if any) options more simple to write that are also easy to use than those designed for command line integration (e.g. PowerShell, Python).\nScripts should be written for command line usage wherever possible."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Scripts Should Follow Command Line Fundamentals/Principles"}),(0,s.jsx)(n.br,{}),"\n","To ensure script-based automation is both easy to use by individual users and is also easy to integrate into scale automation, developers should follow command line\n101 principles. The following are the key principles involved:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Return a Relevant Exit Code"}),(0,s.jsx)(n.br,{}),"\n","Scripts on the command line should return an exit code of 0 to represent a successful execution/outcome. A non-zero exit code should be returned\nto represent a non-successful execution/outcome. Good script-based automation tools use different non-zero exit codes to represent exact reasons for the operation\nfailing."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Provide Useful Information in Standard Output"}),(0,s.jsx)(n.br,{}),"\n","Scripts should provide information useful to a user (or scale automation) in standard output (e.g. console print screen). This makes it easy\nfor a user of the script automation to understand exactly what happened and ideally to be able to make a decision on the outcome by simply reading\nthe output. Furthermore, the use of standard output is one of the easiest output interface for integration into scale automation (e.g. redirected to a log file)."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Provide Error Information in Standard Error"}),(0,s.jsx)(n.br,{}),"\n",'Scripts should provide information on errors that occur in standard error. The error information should be ideally written\nin layman\'s terms so that it is easy for the user to understand the context of the problem (i.e. "an error occurred" is not generally a good error statement).\nFurthermore, the use of standard error is one of the easiest output interface for integration into scale automation (e.g. redirected to a log file).']}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Prefer Options/Parameters on the Command Line"}),(0,s.jsx)(n.br,{}),"\n","Most script terminals and command line tools support or require options/parameters be supplied on the command line. This is the easiest way to pass information into a\ncommand line tool and is thus preferred over other options. Environment variables are also a reasonable choice as a second option; however, they are not\nas easily discoverable for users and require more setup requirements for scale automation. They are thus less preferred. Providing information to\ncommand line tools via a file/settings file is not generally a good choice because it reduces the flexibility of the usage for the user of the tool.\nLightweight command line tools generally avoid file-based options for providing information to the tool in preference for options/parameters directly on\nthe command line itself. File-based options additionally run more risk of exposing secrets when information within the file contains\nthings such as passwords, access tokens. This is a violation of Azure's security standards having secrets in plain text."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# Command line tools should ideally pass in necessary information to the command \n# on the command line.\nPS ~/custom_scripts.1.0.0> ./Invoke-FirmwareUpdate.ps1 -ImagePath ./firmware/GB32M34.bin -LogDirectory ./logs/firmware\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Log Directories Should be Supplied Not Implied"}),(0,s.jsx)(n.br,{}),"\n","If the script emits log files, the log file directory should be definable by the user or scale automation on the command line. This is generally\nadvisable over the use of an environment variable for the reasons noted above. It is also important that the tool support both full and relative paths for\nany file system path references. It is additionally advisable that log files include a timestamp in the name of the file. This ensures uniqueness\nof each log file and avoids files being overwritten when the command line tool is executed multiple times on the same system. It is also advisable\nto use ISO8601 (i.e. universal round-trip) date/time format as it is both easy to read and sorts chronologically in natural text (e.g. folder explorer) scenarios."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://www.iso.org/iso-8601-date-and-time-format.html",children:"https://www.iso.org/iso-8601-date-and-time-format.html"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'# Command line tools should support full paths\nPS ~/custom_scripts.1.0.0> ./Invoke-FirmwareUpdate.ps1 -LogDirectory /home/anyuser/content.gb200.1.0.0/logs/firmware\n\n# Command line tools should support relative paths\nPS ~/custom_scripts.1.0.0> ./Invoke-FirmwareUpdate.ps1 -LogDirectory ./logs/firmware\n\n# Command line tools should generally produce timestamped log files to ensure uniqueness\n# across multiple executions on the same system. Use "universal round-trip" format.\nPS ~/custom_scripts.1.0.0> ./Invoke-FirmwareUpdate.ps1 -LogDirectory ./logs/firmware -> 2025-04-17T-09-30-00-235Z-firmware-update.log\n'})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"script-extensions-packaging-guidelines",children:"Script Extensions Packaging Guidelines"}),"\n",(0,s.jsxs)(n.p,{children:["The following section covers packaging standards for the creating of script-based automation packages. As noted above, the primary goal of these standards\nis to produce a ",(0,s.jsx)(n.strong,{children:"self-contained package"}),". A self-contained package can be copied/downloaded to a system under test and the scripts within executed\nwith minimal or no additional setup requirements. There are cases where 1st and 3rd party toolsets/binaries will need to be downloaded to the system\nand this topic will be covered at the end of this section."]}),"\n",(0,s.jsxs)(n.p,{children:["The term ",(0,s.jsx)(n.code,{children:"package"})," used in this section refers to a folder structure containing all test content and dependencies. A package can be easily\nzipped and copied around or uploaded to Azure Storage Accounts etc... for use in scale automation scenarios. Packages are a fundamental part of any\nscript-based extensions development process. The following illustrates an example of the recommendation for the folder structure of a package:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"/custom_scripts.1.0.0\n    /binaries\n    /docs\n    /setup\n\n    /Invoke-FirmwareUpdate.ps1\n    /update_firmware.py\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Include Scripts in the Package Root Directory"}),(0,s.jsx)(n.br,{}),"\n","Scripts should generally be added to the root directory of the package. This ensures that scripts can easily reference other scripts\nfor import or execution. It does not matter which language the scripts are written in (e.g. PowerShell, Python). That said, it is additionally\nuseful to organize same-language scripts in subdirectories if desired."]}),"\n",(0,s.jsx)(n.p,{children:"The following illustrates the folder structure of the test content package:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'# Test content scripts should generally go in the root of the package.\n/custom_scripts.1.0.0\n    - Common.psm1\n    - Firmware.Linux.psm1\n    - Firmware.Windows.psm1\n    - Custom.Linux.psd1\n    - Custom.Windows.psd1\n\n# The use of subdirectories to contain "same-language" files is fine as well.\n/custom_scripts.1.0.0\n    /powershell\n        - Common.psm1\n        - Firmware.Linux.psm1\n        - Firmware.Windows.psm1\n        - Custom.Linux.psd1\n        - Custom.Windows.psd1\n    /python\n        - update_ssd_firmware.py\n        - update_nvme_firmware.py\n        - update_fpga_firmware.py\n'})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Include 1st and 3rd Party Toolsets in the Package"}),(0,s.jsx)(n.br,{}),"\n","When reasonable in overall size (e.g. < 10 MB), include any 1st or 3rd party toolsets used/referenced by the test content\nin a ",(0,s.jsx)(n.code,{children:"binaries"}),' subdirectory within the package. Follow the conventions illustrated below to encapsulate the toolsets within appropriate\n"platform-specific" folders. This makes it visually easy to discern which toolsets can be used on which OS platforms and architectures\nand is a well-vetted pattern from the industry at-large.']}),"\n",(0,s.jsx)("div",{children:(0,s.jsx)("mark",{children:(0,s.jsxs)(n.p,{children:["Note that it is also common to pre-install toolsets when possible especially on Linux systems. This reduces the overhead\nof having to carry toolsets/binaries in the test content package. One good option is to include scripts in the package\n",(0,s.jsx)("b",{children:"/setup"})," folder that can be used to install the toolsets. Users or automation can easily run these scripts once before then\nrunning scripts within the same package."]})})}),"\n",(0,s.jsx)("br",{}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# Toolsets and binaries used/referenced by the test content scripts should be contained\n# within platform-specific subdirectories within the package.\n/custom_scripts.1.0.0\n\n    # Toolsets go in 'binaries' subdirectory\n    /binaries\n\n        # Toolsets for the specific platform/architecture (e.g. linux-x64) go in\n        # a subdirectory named for that platform/architecture.\n        /customutil\n            # Toolsets that work on Linux OS and ARM64 CPU architectures.\n            /linux-arm64\n                - customutil\n\n            # Toolsets that work on Linux OS and X64 CPU architectures.\n            /linux-x64\n                - customutil\n\n        /ipmiutil\n            # Toolsets that work on Windows OS and ARM64 CPU architectures.\n            /win-arm64\n                - ipmiutil.exe\n\n            # Toolsets that work on Windows OS and X64 CPU architectures.\n            /win-x64\n                - ipmiutil.exe\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Include Documentation in the Package"}),(0,s.jsx)(n.br,{}),"\n","Each hardware program comes with special considerations. Documentation related to the specific program should be included in either the root\ndirectory for the package (e.g. README.md) or in a ",(0,s.jsx)(n.code,{children:"docs"})," subdirectory within the package. Any non-automated setup requirments should be clearly\ndocumented."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# Documentation providing context and usage information should be contained within\n# a 'docs' subdirectory.\n/custom_scripts.1.0.0\n    /docs\n        - README.md\n        - SETUP_REQUIREMENTS.md\n        - USAGE.md\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Include System Setup Scripts in the Package"}),(0,s.jsx)(n.br,{}),"\n","With some hardware program qualification scenarios, there are 1-time/initial setup requirements that are automated with scripts. For example, in certain\nscenarios, it is highly desirable to pre-install certain toolsets (e.g. install ipmiutil from a Linux package manager). These toolsets, once installed, greatly simplify the\nintegration/referencing of the toolsets within the test content scripts. Scripts that are used for 1-time/initial system setup should be included in a\n",(0,s.jsx)(n.code,{children:"setup"})," subdirectory. Any installer applications (e.g. MSI, debian packages) should be included in this directory as well."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# System setup scripts (and related content) should be contained within \n# a 'setup' subdirectory.\n/content.gb200.1.0.0\n    /setup\n        - install-packages.sh\n        - install-pwsh.sh\n        - install-python.sh\n        - install-docker.sh\n        - install-debug-toolsets.sh\n        - debug-toolsets.deb\n"})}),"\n"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var s=t(6540);const i={},o=s.createContext(i);function r(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);