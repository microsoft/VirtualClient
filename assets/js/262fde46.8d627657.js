"use strict";(self.webpackChunkvirtualclient=self.webpackChunkvirtualclient||[]).push([[4931],{6229:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>d});var i=t(5893),r=t(3905);const o={id:"design"},a="Platform Design",s={id:"overview/design",title:"Platform Design",description:"The following sections cover important design aspects of the Virtual Client platform application. This document is written for engineers and technical roles who",source:"@site/docs/overview/0020-design.md",sourceDirName:"overview",slug:"/overview/design",permalink:"/VirtualClient/docs/overview/design",draft:!1,unlisted:!1,editUrl:"https://github.com/microsoft/VirtualClient/edit/main/website/docs/overview/0020-design.md",tags:[],version:"current",frontMatter:{id:"design"},sidebar:"tutorialSidebar",previous:{title:"Platform Features",permalink:"/VirtualClient/docs/overview/features"},next:{title:"Platform Roadmap",permalink:"/VirtualClient/docs/overview/roadmap"}},l={},d=[{value:"Application Concepts",id:"application-concepts",level:2},{value:"Workload/Test Profiles",id:"workloadtest-profiles",level:3},{value:"Monitoring Profiles",id:"monitoring-profiles",level:3},{value:"Workload Dependency Packages",id:"workload-dependency-packages",level:3},{value:"Multi-Instance API Support",id:"multi-instance-api-support",level:3},{value:"Telemetry Support",id:"telemetry-support",level:3},{value:"Data Correlation",id:"data-correlation",level:3},{value:"File Upload Support",id:"file-upload-support",level:3},{value:"Application Development Concepts",id:"application-development-concepts",level:2},{value:"Implementation Concepts",id:"implementation-concepts",level:3},{value:"Telemetry/Logging Concepts",id:"telemetrylogging-concepts",level:3}];function c(e){const n={a:"a",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.ah)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"platform-design",children:"Platform Design"}),"\n",(0,i.jsx)(n.p,{children:"The following sections cover important design aspects of the Virtual Client platform application. This document is written for engineers and technical roles who\nare interested in how the Virtual Client platform and application is designed. The application itself is a .NET 8.0 command line application written in C# that\nis has both cross-platform and multi-architecture support. It is compiled to support both Windows and Linux operating system platforms as well as x64 and arm64\narchitectures. The choice to implement the application using managed code was made to enable a foundation for ease-of-rapid feature development at the same time\nas meeting all of the requirements for cross-platform + architecture support. Additionally, the .NET 8.0 framework integrates all of the performance and runtime\nefficiency work done by the .NET Core team over the past 5 years into a unified platform."}),"\n",(0,i.jsx)(n.h2,{id:"application-concepts",children:"Application Concepts"}),"\n",(0,i.jsx)(n.p,{children:"The following sections describes some of the high-level concepts and features sets of the Virtual Client platform."}),"\n",(0,i.jsx)(n.h3,{id:"workloadtest-profiles",children:"Workload/Test Profiles"}),"\n",(0,i.jsx)(n.p,{children:"Workload profiles define a set of one or more different ways to run a given workload or test on a system. The primary goal of these workload profiles is to evaluate the system\nin a wide range of different ways. This in turn ensures that each round of execution of a workload on the Virtual Client platform can produce a breadth and depth of results\nthat are useful in comparing the performance of the system. Each of the workload profiles are tailored based on feedback from subject matter expert teams in the\nAzure organization as well as from empirical evidence derived from running them in large-scale experiments. The Virtual Client has ran on more than\na million VM systems (Windows and Linux) in the Azure cloud."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/VirtualClient/docs/overview/",children:"Workloads and Profiles Supported"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://github.com/microsoft/VirtualClient/blob/main/src/VirtualClient/VirtualClient.Main/profiles/PERF-CPU-OPENSSL.json&version=GBmaster",children:"Example Profile"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://github.com/microsoft/VirtualClient/blob/main/src/VirtualClient/VirtualClient.Main/profiles",children:"Profiles Supported"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/VirtualClient/docs/guides/0200-usage-examples",children:"Usage Examples"})}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Using the example below as a reference, there are a 3 different fundamental sections inside a workload profile:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Parameters"}),(0,i.jsx)(n.br,{}),"\n","At the top of most workload profiles are a set of one or more parameters. These parameters are referenced by each of the other\ncomponents throughout the rest of the profile. Before a workload runs, all parameter references in a workload profile will be\nreplaced with the concrete values defined in the profile parameters at the top. Additionally, any parameters defined at the top\nof a workload profile can be overridden on the command line. This feature allows for flexibility in running workloads for different\nscenarios while not reducing the cohesion and validity of the goals that originally informed the design of the workload profile (this\nlatter point is why not all parameters are allowed be overridden)."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# An example of overriding the profile parameters so to use a smaller DiskSpd test file footprint. This might\n# for example be a scenario where the local/temp disk on an Azure virtual machine should be tested. These disks\n# are often very small and so the default 496G file size would be way to big.\n#\n# In the example JSON below, you will also see placeholders in the text of some of the step-specific parameters. These\n# placeholders will match the names of the parameters at the top and will be replaced with a value before executing\n# the step (e.g. [diskfillsize]).\nVirtualClient.exe --profile=PERF-IO-DISKSPD.json --timeout=1440 --parameters:DiskFillSize=30G,,,FileSize=30G\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Actions"}),(0,i.jsx)(n.br,{}),"\n","This section contains the workload execution workflow. Each of the steps in the 'Actions' section will be executed in sequential order. This section\nallows a given workload (or more than 1) to be executed on the system in a wide range of ways to cover system performance and reliability\nrequirements thoroughly and with depth. Workloads and tests are often part of the actions as they are intended to utilize the system\nand its resources in a measurable way. The term 'Executor' will be used often with components in the 'Actions' section."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Dependencies"}),(0,i.jsx)(n.br,{}),"\n","This section contains steps for downloading and installing dependencies and for configuring the system to meet preliminary requirements for running\na specific workload. In the example below, there are 2 dependencies that must be accounted for before the workload is executed. All unformatted disks\non the system should be initialized and formatted. Additionally the package containing the workload binaries/executables itself should be downloaded\nto the system from an Azure storage account blob store. Other examples of dependencies that are required include different Linux packages\nrequired, libraries/frameworks (e.g. PowerShell 7.0), scripts and configuring the system itself."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n    "Description": "DiskSpd I/O Stress Performance Workload",\n    "Parameters": {\n        "DiskFillSize": "500GB",\n        "FileSize": "496G",\n        "Tests": null\n    },\n    "Actions": [\n      {\n            "Type": "DiskSpdExecutor",\n            "Parameters": {\n                "Scenario": "DiskFill",\n                "PackageName": "diskspd",\n                "CommandLine": "-c[diskfillsize] -b256K -si4K -t1 -o64 -w100 -Suw -W15 -D -L",\n                "TestName": "disk_fill",\n                "FileName": "diskspd-test.dat",\n                "DiskFill": true,\n                "DiskFillSize": "$.Parameters.DiskFillSize",\n                "Tags": "IO,DiskSpd,randwrite",\n                "ProcessModel": "SingleProcessPerDisk",\n                "DeleteTestFilesOnFinish": false,\n                "Tests": "$.Parameters.Tests"\n            }\n        }\n    ],\n    "Dependencies": [\n        {\n            "Type": "FormatDisks"\n        },\n        {\n            "Type": "DependencyPackageInstallation",\n            "Parameters": {\n                "BlobContainer": "packages",\n                "BlobName": "diskspd.1.2.0.zip",\n                "PackageName": "diskspd",\n                "Extract": true\n            }\n        }\n    ]\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"monitoring-profiles",children:"Monitoring Profiles"}),"\n",(0,i.jsx)(n.p,{children:"Monitoring profiles define a set of one or more different background system monitors to run during the execution of the application. For example, a common monitoring scenario\nis the need to capture performance counters from the system. Monitoring profiles are often used in conjunction with workload profiles to capture performance\nand reliability information while workloads are executing in-parallel. The Virtual Client runs a default monitoring profile (MONITORS-DEFAULT.json) when a specific monitoring\nprofile is not provided. However, a different monitoring profile can be supplied on the command line if desired (extensibility)."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/VirtualClient/docs/overview/",children:"Monitors and Profiles Supported"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://github.com/microsoft/VirtualClient/blob/main/src/VirtualClient/VirtualClient.Main/profiles/MONITORS-DEFAULT.json&version=GBmaster",children:"Example Profile"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://github.com/microsoft/VirtualClient/blob/main/src/VirtualClient/VirtualClient.Main/profiles",children:"Profiles Supported"})}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Using the example below as a reference, there are a 3 different fundamental sections inside a workload profile:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Parameters"}),(0,i.jsx)(n.br,{}),"\n","Parameters in monitoring profiles serve the same purpose as they do in workload profiles. See the 'Workload Profiles' section above\nfor details."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# An example of overriding the profile parameters to capture\n#\n# In the example JSON below, you will also see placeholders in the text of some of the step-specific parameters. These\n# placeholders will match the names of the parameters at the top and will be replaced with a value before executing\n# the step (e.g. [diskfillsize]).\nVirtualClient.exe --profile=MONITORS-DEFAULT.json --timeout=1440 --parameters:CounterMonitorFrequency=00:05:00,,,CounterMonitorWarmupPeriod=00:00:30\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Monitors"}),(0,i.jsx)(n.br,{}),"\n","This section contains one or more background monitors to run on the system. These are often intended to be ran in the background while the\nworkloads defined in a workload profile are running. Each of the steps in the 'Monitors' section will be executed on a background thread to run\nconcurrently and independently of each other. The monitors will typically run independently from workloads that are running on the system as well."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Dependencies"}),(0,i.jsx)(n.br,{}),"\n","Dependencies in monitoring profiles serve the same purpose as they do in workload profiles. See the 'Workload Profiles' section above\nfor details."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n    "Description": "Default Monitors",\n    "Parameters": {\n        "CounterMonitorFrequency": "00:10:00",\n        "CounterMonitorWarmupPeriod": "00:05:00"\n    }\n    "Dependencies": [\n        {\n          "Type": "AptPackageInstallation",\n          "Parameters": {\n            "Packages": "atop",\n            "AllowUpgrades": true\n          }\n        }\n    ],\n    "Monitors": [\n        {\n            "Type": "PerfCounterMonitor",\n            "Parameters": {\n                "Scenario": "PerformanceCounterMonitoring",\n                "MonitorFrequency": "$.Parameters.CounterMonitorFrequency",\n                "MonitorWarmupPeriod": "$.Parameters.CounterMonitorWarmupPeriod"\n            }\n        }\n    ]\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"workload-dependency-packages",children:"Workload Dependency Packages"}),"\n",(0,i.jsx)(n.p,{children:"The section above talked a bit about defining dependencies in Virtual Client workload and monitoring profiles. The Virtual Client platform has a model defined for how dependencies should\nbe packaged. Virtual Client workload and dependency packages follow the strict schema for the folder structure of the packages that allows for putting binaries, scripts and\nother files in the package separated by their target runtime OS and architecture platforms (e.g. win-x64, win-arm64, linux-x64, linux-arm64). Workload and dependency\npackages are typically stored in an Azure storage account blob store. However, Virtual Client also supports the ability to include the packages alongside the runtime platform\nand they will be incorporated at runtime without need of download."}),"\n",(0,i.jsx)(n.p,{children:'In addition to workload and dependency packages stored in a Storage Account location, there are some packages that are packaged directly with the Virtual Client application itself.\nThe are called "built-in packages". There is no specific rhyme or reason to what is determined to qualify as a built-in package; however, they are as a general rule dependencies\nthat are needed by more than 1 workload and often operating-system specific libraries/toolsets/binaries. Technically, any of the workload packages and dependencies could be\nbundled with the Virtual Client itself removing the requirement at runtime of downloading any packages. This is not done by default because it would cause the size of\nthe Virtual Client package to be very large. This is an issue for deployment simplicity and reliability in cloud environments. With that said, the Virtual Client\nOfficial build pipeline can support producing different packages/bundles for the Virtual Client that contain more workloads built-in.'}),"\n",(0,i.jsx)(n.h3,{id:"multi-instance-api-support",children:"Multi-Instance API Support"}),"\n",(0,i.jsx)(n.p,{children:"Certain workload scenarios require multiple systems to operate (e.g. client/server networking workloads and high-performance compute workloads). These workloads have a requirement to communicate\nwith each other to be able to synchronize client-side executions with server-side expectations. The Virtual Client has a self-hosted REST API that is used\nfor this purpose. This REST API enables simple HTTP communications between 2 or more different instances of the Virtual Client. The REST API provides the following\nsupport:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/VirtualClient/docs/guides/0020-client-server",children:"Client/Server Support"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"State Management"}),(0,i.jsx)(n.br,{}),"\n","The API enables both the client and the server instances of the application to preserve state on the local system. Additionally, state objects/requests can be\npassed from the client to the server (or vice-versa) to be saved on the remote endpoint system. State is used primarily by workload executors to synchronize handshakes and\nrequirements between the client and the server. For example, the server workload must be confirmed online and running in the NTttcp network throughput workload\nbefore the client can start. The client will perform a set of synchronization steps to ensure this is the case."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Heartbeats"}),(0,i.jsx)(n.br,{}),"\n","The API enables one instance of the Virtual Client to confirm another instance of the Virtual Client running on a different system is up and running. This is called\na heartbeat."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Instructions/Eventing"}),(0,i.jsx)(n.br,{}),"\n","The API also enables one instance of the Virtual Client to send an event request to another instance of the application. An event is typically a request for the\ntarget endpoint instance to take an actions. For example in the NTttcp network throughput workload, the client will request that the server-side workload startup by sending it an\nevent request. It will then poll for a particular server-side state to determine when the server-side workload is definitively up and running."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"telemetry-support",children:"Telemetry Support"}),"\n",(0,i.jsx)(n.p,{children:"One of the most important features of the Virtual Client platform is that it provides a lot of very useful telemetry. Telemetry emitted by the application follows a consistent schema\n(based on Application Insights) that is designed to enable strong correlation between data related to the process/system executing the application and data related to workloads and\nmonitors."}),"\n",(0,i.jsx)(n.p,{children:"Telemetry/data emitted by the Virtual Client application is divided into 4 different categories of data:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Traces/Logs/Errors"}),(0,i.jsx)(n.br,{}),"\n","The Virtual Client is heavily instrumented with structured logging/tracing logic. This ensures that the inner workings of the application can\nare easily visible to the user. This is particularly important for debugging scenarios.  Errors are a specific type of log/trace that indicate\nissues that happen during the execution of Virtual Client commands. These represent situations that may be causing the Virtual Client to fail or\nto work in unexpected ways."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Workload Metrics"}),(0,i.jsx)(n.br,{}),"\n","Workload metrics are measurements and information captured from the output of a particular workload (e.g. DiskSpd, FIO, Coremark) that represent\nperformance data from the system under test. Metrics also include measurements of the system performance and reliability such as performance counters."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"System Events"}),(0,i.jsx)(n.br,{}),"\n","System events describe certain types of important information on the system beyond simple performance measurements. This might for example\ninclude Windows registry changes or special event logs."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"data-correlation",children:"Data Correlation"}),"\n",(0,i.jsx)(n.p,{children:'To enable correlation between data from an execution system and the Virtual Client, metadata is supplied to the Virtual Client on the command line. This is a simple way to "connect-the-dots"\nwhen creating reports based on the data. This metadata will be included with every telemetry event/message that is emitted by the Virtual Client. The following shows an example of the schema\nand how metadata is supplied on the command line as well as what the contents of a single telemetry event emitted would look like.'}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/VirtualClient/docs/guides/0040-telemetry",children:"Data/Telemetry Support"})}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'VirtualClient.exe --profile=PERF-CPU-OPENSSL.json --timeout=1440 --experimentId=2451d02e-b22b-4e8a-9a1f-5436512dbc01 --agentId=virtualmachine01 --metadata:"anyCorrelationId=identifier,,,property2=123,,,property3=true"\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n    "timestamp": "2021-04-19T16:01:31.9148275Z",\n    "message": "OpenSSLExecutor.Execute",\n    "severityLevel": "1",\n    "itemType": "trace",\n    "operation_Id": "6978d01d-b28d-4f81-8a0e-6296592dad07",\n    "operation_ParentId": "00000000-0000-0000-0000-000000000000",\n    "appName": "VirtualClient",\n    "appHost": "virtualmachine01",\n    "sdkVersion": "1.9.0.0",\n    "customDimensions": {\n        "agentId": "virtualmachine01",\n        "experimentId": "2451d02e-b22b-4e8a-9a1f-5436512dbc01",\n        "metadata": {\n            "anyCorrelationId": "identifier",\n            "property2": 123,\n            "property3": true\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"file-upload-support",children:"File Upload Support"}),"\n",(0,i.jsx)(n.p,{children:'In addition to having support for structured telemetry, the Virtual Client platform supports the ability to upload files/content to an Azure storage account\nblob store. This is a need often enough with certain types of background monitors that produce very large results files too large to send through traditional\ntelemetry pipelines. Any component in the Virtual Client can be developed to upload files/content to a target blob store. Then the user of the application simply\npasses in a connection string or SAS URI to the target "content" store on the command line.'}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/VirtualClient/docs/guides/0600-integration-blob-storage",children:"Blob Store Support"})}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"VirtualClient.exe --profile=PERF-CPU-OPENSSL.json --timeout=1440 --contentStore={ConnectionString or SASTokenUri}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"application-development-concepts",children:"Application Development Concepts"}),"\n",(0,i.jsx)(n.p,{children:"The following sections cover some of the important application development concepts for contributing to the Virtual Client platform. Given the above concepts covered,\nthe next sections dive a bit more into the depths of the application (coding concepts)."}),"\n",(0,i.jsx)(n.h3,{id:"implementation-concepts",children:"Implementation Concepts"}),"\n",(0,i.jsx)(n.p,{children:"The following concepts and terminology is used to describe the various coded components that exist in Virtual Client codebase."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Workload Executors"}),(0,i.jsx)(n.br,{}),"\n","A workload executor is a class/implementation that is responsible for managing initialization requirements and the execution of a given workload. Workloads can\nbe vastly different than each other with regards to execution requirements (e.g. which OS they can operate on, command line parameters, length of run etc...).\nThe workload executor foundation in Virtual Client ensures that these details are all encapsulated into one or more executors specific to\nthat workload. Furthermore, workload executors can be implemented to support parameterization for a wide range of different ways to run a\ngiven workload. Workload profiles in the Virtual Client platform will have one or more workload executors defined in the 'Actions' section."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Background Monitors"}),(0,i.jsx)(n.br,{}),"\n","A background monitor is a class/implementation that is responsible for gathering information from the system on a background thread during the lifetime of the\nVirtual Client application runtime (e.g. performance counters). Monitors are implemented to start a long-running background task but will return immediately so as\nto avoid blocking the main thread."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Dependency Installers/Handlers"}),(0,i.jsx)(n.br,{}),"\n","A dependency handler is a class/implementation that is responsible for downloading, installing and setting up dependencies on the system as preliminary requirements\nbefore any workloads or monitors are executed. If any one of the dependencies fail to perform their task, the Virtual Client application will exit returning a code that\nwill indicate what actually failed."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Components"}),(0,i.jsx)(n.br,{}),"\n",'All of the above noted types of classes/implementations in the Virtual Client codebase are collectively called "components". This is a generic\nterm directly related to the base/fundamental class in the Virtual Client, the  ',(0,i.jsx)(n.a,{href:"https://github.com/microsoft/VirtualClient/blob/main/src/VirtualClient/VirtualClient.Contracts/VirtualClientComponent.cs",children:"VirtualClientComponent"}),".\nAll workload executors, background monitors and dependency handlers in the Virtual Client codebase derive from this class."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"telemetrylogging-concepts",children:"Telemetry/Logging Concepts"}),"\n",(0,i.jsx)(n.p,{children:"To ensure consistency, a set of common extension methods are used to capture all telemetry from the operations of the application or the execution of workloads and monitors."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://github.com/microsoft/VirtualClient/blob/main/src/VirtualClient/VirtualClient.Contracts/VirtualClientLoggingExtensions.cs",children:"Logging Extensions"})}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.ah)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},3905:(e,n,t)=>{t.d(n,{ah:()=>d});var i=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,i,r=function(e,n){if(null==e)return{};var t,i,r={},o=Object.keys(e);for(i=0;i<o.length;i++)t=o[i],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)t=o[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=i.createContext({}),d=function(e){var n=i.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},c={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},h=i.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,h=s(e,["components","mdxType","originalType","parentName"]),p=d(t),u=r,m=p["".concat(l,".").concat(u)]||p[u]||c[u]||o;return t?i.createElement(m,a(a({ref:n},h),{},{components:t})):i.createElement(m,a({ref:n},h))}));h.displayName="MDXCreateElement"}}]);